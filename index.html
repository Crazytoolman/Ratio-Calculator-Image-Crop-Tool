<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="专业的比例计算器和图像裁切工具，支持常用照片比例、屏幕比例等，自定义比例计算更方便，在线裁切图片">
    <title>比例计算器与图像裁切拼接工具 - 智能尺寸计算与图片裁切拼接</title>
    <!-- SVG Favicon -->
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg viewBox='0 0 48 48' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3ClinearGradient id='icon-grad-2' x1='48' y1='0' x2='0' y2='48' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='0%25' stop-color='%23FF2D55' /%3E%3Cstop offset='100%25' stop-color='%23FF9500' /%3E%3C/linearGradient%3E%3C/defs%3E%3Cpath d='M12 38V12C12 9.79086 13.7909 8 16 8H40' stroke='url(%23icon-grad-2)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M36 10V36C36 38.2091 34.2091 40 32 40H8' stroke='url(%23icon-grad-2)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M12 14V6' stroke='url(%23icon-grad-2)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M42 8H34' stroke='url(%23icon-grad-2)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M6 40H14' stroke='url(%23icon-grad-2)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M36 34V42' stroke='url(%23icon-grad-2)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* 浅色主题 - Apple风格 */
            --bg-gradient-1: #f5f5f7;
            --bg-gradient-2: #e8e8ed;
            --bg-gradient-3: #fafafa;
            --bg-gradient-4: #ffffff;

            --card-bg: rgba(255, 255, 255, 0.72);
            --card-bg-gradient: linear-gradient(135deg, rgba(255, 255, 255, 0.72) 0%, rgba(251, 251, 253, 0.72) 100%);
            --card-shadow: 0 2px 16px rgba(0, 0, 0, 0.08);
            --card-hover-shadow: 0 4px 24px rgba(0, 0, 0, 0.12);

            --primary-gradient: linear-gradient(135deg, #1d1d1f 0%, #424245 100%);
            --secondary-gradient: linear-gradient(135deg, #6e6e73 0%, #86868b 100%);
            --accent-gradient: linear-gradient(135deg, #0071e3 0%, #0077ed 100%);
            --success-gradient: linear-gradient(135deg, #30d158 0%, #32d159 100%);
            --danger-gradient: linear-gradient(135deg, #ff3b30 0%, #ff453a 100%);

            --text-primary: #1d1d1f;
            --text-secondary: #6e6e73;
            --text-light: #86868b;

            --border-color: rgba(0, 0, 0, 0.1);
            --border-glow: rgba(0, 0, 0, 0.2);

            --input-bg: rgba(255, 255, 255, 0.8);
            --input-focus-bg: rgba(255, 255, 255, 1);

            --success-bg: rgba(48, 209, 88, 0.1);
            --success-text: #30d158;

            --preview-bg: linear-gradient(135deg, rgba(242, 242, 247, 0.6) 0%, rgba(250, 250, 250, 0.6) 100%);
        }

        /* 深色主题 - Apple风格 */
        body.dark-theme {
            --bg-gradient-1: #000000;
            --bg-gradient-2: #1c1c1e;
            --bg-gradient-3: #2c2c2e;
            --bg-gradient-4: #1d1d1f;

            --card-bg: rgba(28, 28, 30, 0.72);
            --card-bg-gradient: linear-gradient(135deg, rgba(28, 28, 30, 0.72) 0%, rgba(44, 44, 46, 0.72) 100%);
            --card-shadow: 0 2px 16px rgba(0, 0, 0, 0.6);
            --card-hover-shadow: 0 4px 24px rgba(0, 0, 0, 0.8);

            --text-primary: #f5f5f7;
            --text-secondary: #a1a1a6;
            --text-light: #86868b;

            --border-color: rgba(255, 255, 255, 0.15);
            --border-glow: rgba(255, 255, 255, 0.25);

            --input-bg: rgba(58, 58, 60, 0.5);
            --input-focus-bg: rgba(58, 58, 60, 0.8);

            --success-bg: rgba(48, 209, 88, 0.15);
            --success-text: #30d158;

            --preview-bg: linear-gradient(135deg, rgba(44, 44, 46, 0.4) 0%, rgba(58, 58, 60, 0.4) 100%);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(to bottom, var(--bg-gradient-1) 0%, var(--bg-gradient-2) 50%, var(--bg-gradient-3) 75%, var(--bg-gradient-4) 100%);
            min-height: 100vh;
            padding: 40px 20px;
            color: var(--text-primary);
            line-height: 1.6;
            position: relative;
            overflow-x: hidden;
            transition: all 0.5s ease;
        }

        /* 背景动画粒子 - Apple风格更加微妙 */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 50%, rgba(0, 113, 227, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.02) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .dark-theme::before {
            background-image:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.02) 0%, transparent 50%);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        /* 控制栏 - 主题和语言切换 */
        .controls-bar {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 1000;
            display: flex;
            gap: 12px;
        }

        /* 主题切换器 */
        .theme-toggle,
        .lang-toggle {
            display: flex;
            gap: 4px;
            background: var(--card-bg-gradient);
            padding: 4px;
            border-radius: 50px;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
        }

        .theme-btn,
        .lang-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 50px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: transparent;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .theme-btn.active,
        .lang-btn.active {
            background: var(--input-bg);
            color: var(--text-primary);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .theme-btn:hover:not(.active),
        .lang-btn:hover:not(.active) {
            background: rgba(0, 0, 0, 0.05);
            color: var(--text-primary);
        }

        .dark-theme .theme-btn:hover:not(.active),
        .dark-theme .lang-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
        }

        /* 头部样式 */
        .header {
            text-align: center;
            margin-bottom: 48px;
            animation: fadeInDown 0.8s ease;
        }

        .header-icon {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 24px;
            animation: float 3s ease-in-out infinite;
        }

        .header-svg {
            width: 60px;
            height: 60px;
            filter: drop-shadow(0 8px 16px rgba(102, 126, 234, 0.25));
            transition: transform 0.3s ease;
        }

        .header-svg:hover {
            transform: scale(1.1) rotate(5deg);
        }

        .dark-theme .header-svg {
            filter: drop-shadow(0 8px 16px rgba(255, 255, 255, 0.15));
        }

        .header h1 {
            font-size: 42px;
            line-height: 1.25;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 12px;
            letter-spacing: -1px;
        }

        .header p {
            font-size: 16px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* 卡片样式 */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 48px;
            /* 统一间距增加到 48px，比例更美观 */
            margin-bottom: 48px;
        }

        .card {
            background: var(--card-bg-gradient);
            border-radius: 32px;
            --card-padding: 28px;
            padding: var(--card-padding);
            box-shadow: var(--card-shadow);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            animation: fadeInUp 0.8s ease;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card:hover::before {
            opacity: 1;
        }

        .card:hover {
            box-shadow: var(--card-hover-shadow);
            transform: translateY(-4px);
        }

        .card-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 28px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dark-theme .card-title {
            background: linear-gradient(135deg, #f5f5f7 0%, #ffffff 50%, #e5e5e7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
        }

        /* 比例选择区域 */
        .ratio-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 28px;
        }

        .ratio-btn {
            background: var(--input-bg);
            border: 2px solid var(--border-color);
            border-radius: 20px;
            padding: 16px 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .ratio-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.2), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        .ratio-btn:hover::before {
            width: 200%;
            height: 200%;
        }

        .ratio-btn:hover {
            border-color: var(--border-glow);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.2);
        }

        .ratio-btn.active {
            background: var(--primary-gradient);
            border-color: transparent;
            color: white;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
            transform: translateY(-2px);
        }

        .ratio-value {
            font-size: 18px;
            font-weight: 800;
            margin-bottom: 6px;
            position: relative;
            z-index: 1;
        }

        .ratio-label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
            position: relative;
            z-index: 1;
        }

        .ratio-btn.active .ratio-label {
            color: rgba(255, 255, 255, 0.9);
        }

        /* 自定义比例 */
        .custom-ratio {
            padding: 16px;
            background: var(--preview-bg);
            border-radius: 20px;
            border: 2px dashed var(--border-color);
            transition: all 0.3s ease;
        }

        .custom-ratio:hover {
            border-color: var(--border-glow);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .custom-ratio-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .custom-input-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .custom-input-group input {
            flex: 1;
            min-width: 0;
            max-width: 100%;
            padding: 12px 14px;
            border: 2px solid var(--border-color);
            border-radius: 16px;
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            background: var(--input-bg);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .custom-input-group input:focus {
            outline: none;
            border-color: var(--border-glow);
            background: var(--input-focus-bg);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        .custom-input-group .separator {
            font-size: 28px;
            font-weight: 800;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* 预览区域 */
        .preview-card {
            text-align: center;
            display: flex;
            flex-direction: column;
        }

        .preview-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .preview-container {
            flex: 1;
            background: var(--preview-bg);
            border-radius: 24px;
            padding: 60px 24px;
            margin-bottom: 28px;
            min-height: 360px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .preview-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.05) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        .preview-box {
            border: 3px dashed var(--text-primary);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            animation: pulse 3s ease-in-out infinite;
            position: relative;
            z-index: 1;
        }

        .dark-theme .preview-box {
            background: rgba(58, 58, 60, 0.6);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 32px rgba(255, 255, 255, 0.1);
        }

        .preview-ratio-text {
            font-size: 36px;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .preview-description {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        /* 结果显示 */
        .result-display {
            background: var(--success-gradient);
            border-radius: 20px;
            padding: 24px;
            text-align: center;
            box-shadow: 0 4px 16px rgba(67, 233, 123, 0.3);
        }

        .result-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 8px;
            font-weight: 600;
        }

        .result-value {
            font-size: 30px;
            font-weight: 800;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* 计算区域 */
        .calculator-section {
            grid-column: span 2;
        }

        .current-ratio {
            font-size: 15px;
            color: var(--text-secondary);
            margin-bottom: 28px;
            padding: 20px;
            background: var(--preview-bg);
            border-radius: 16px;
            border-left: 5px solid;
            border-image: var(--primary-gradient) 1;
            font-weight: 600;
        }

        .dark-theme .current-ratio {
            color: var(--text-primary);
            border-image: linear-gradient(135deg, #f5f5f7 0%, #e5e5e7 100%) 1;
        }

        .current-ratio-value {
            font-weight: 800;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dark-theme .current-ratio-value {
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .input-groups {
            display: grid;
            gap: 28px;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: end;
        }

        .input-field {
            position: relative;
        }

        .input-field label {
            display: block;
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .input-field input {
            width: 100%;
            padding: 18px 24px;
            border: 2px solid var(--border-color);
            border-radius: 16px;
            font-size: 20px;
            font-weight: 700;
            transition: all 0.3s ease;
            background: var(--input-bg);
            color: var(--text-primary);
        }

        .input-field input::placeholder {
            color: var(--text-light);
        }

        .input-field input:focus {
            outline: none;
            border-color: var(--border-glow);
            background: var(--input-focus-bg);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .input-field input.calculated {
            background: var(--success-gradient);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 16px rgba(67, 233, 123, 0.3);
        }

        .input-field input.calculated::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .arrow-icon {
            font-size: 28px;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: pulse 2s ease-in-out infinite;
            margin-bottom: 8px;
        }

        /* 清空按钮 */
        .clear-btn {
            width: 100%;
            padding: 18px;
            background: var(--danger-gradient);
            color: white;
            border: none;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: 28px;
            box-shadow: 0 4px 16px rgba(250, 112, 154, 0.3);
            position: relative;
            overflow: hidden;
        }

        .clear-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        .clear-btn:hover::before {
            width: 300%;
            height: 300%;
        }

        .clear-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(250, 112, 154, 0.5);
        }

        .clear-btn:active {
            transform: translateY(-2px);
        }

        /* 使用说明 */
        .instructions {
            grid-column: span 2;
            /* 确保在网格中占满两列 */
            background: var(--card-bg-gradient);
            border-radius: 32px;
            padding: 36px;
            box-shadow: var(--card-shadow);
            animation: fadeInUp 1s ease;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instructions h3 {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 20px;
            background: var(--secondary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dark-theme .instructions h3 {
            background: linear-gradient(135deg, #f5f5f7 0%, #ffffff 50%, #e5e5e7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.2));
        }

        .instructions p {
            font-size: 15px;
            color: var(--text-secondary);
            line-height: 1.8;
            margin-bottom: 12px;
            font-weight: 500;
        }

        /* 动画 */
        @keyframes gradientFlow {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-15px);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.03);
            }
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* 图像裁切样式 */
        /* 裁切层级与缩放 */
        .crop-canvas-wrapper {
            position: relative;
            max-width: 100%;
            width: fit-content;
            margin: 0 auto 24px auto;
            border-radius: 12px;
            overflow: auto;
            background: #000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
            touch-action: none;
        }

        .crop-box {
            position: absolute;
            border: 2px solid #fff;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5), inset 0 0 0 1px rgba(0, 0, 0, 0.3);
            cursor: move;
            z-index: 5;
            touch-action: none;
        }

        /* 圆角控制点 - 边缘箭头样式 */
        .corner-radius-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            background: rgba(0, 113, 227, 0.9);
            border: 2px solid #fff;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 15;
            cursor: pointer;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .corner-radius-handle::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
        }

        .corner-radius-handle-top {
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .corner-radius-handle-top::before {
            border-width: 0 4px 6px 4px;
            border-color: transparent transparent white transparent;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -20%);
        }

        .corner-radius-handle-right {
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
        }

        .corner-radius-handle-right::before {
            border-width: 4px 6px 4px 0;
            border-color: transparent white transparent transparent;
            top: 50%;
            left: 50%;
            transform: translate(-20%, -50%);
        }

        .corner-radius-handle-bottom {
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
        }

        .corner-radius-handle-bottom::before {
            border-width: 6px 4px 0 4px;
            border-color: white transparent transparent transparent;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -80%);
        }

        .corner-radius-handle-left {
            left: -12px;
            top: 50%;
            transform: translateY(-50%);
        }

        .corner-radius-handle-left::before {
            border-width: 4px 0 4px 6px;
            border-color: transparent transparent transparent white;
            top: 50%;
            left: 50%;
            transform: translate(-80%, -50%);
        }

        .rotation-controls,
        .border-radius-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding: 16px;
            background: var(--input-bg);
            border-radius: 16px;
        }

        .control-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            white-space: nowrap;
            min-width: 70px;
        }

        .control-slider {
            flex: 1;
            accent-color: var(--primary-color);
        }

        .control-input {
            width: 70px;
            padding: 8px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            text-align: center;
            background: var(--input-bg);
            color: var(--text-primary);
        }

        .zoom-input {
            background: transparent;
            border: none;
            color: white;
            font-size: 12px;
            width: 48px;
            text-align: center;
            outline: none;
            font-family: inherit;
        }

        .zoom-btn-small {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Toast Message */
        .toast-message {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .toast-message.show {
            opacity: 1;
        }

        .image-crop-section {
            grid-column: span 2;
        }

        .upload-area {
            position: relative;
            /* 移除 min-height: 400px，让容器随内容（如裁切框）自动收缩 */
            width: 100%;
        }

        .upload-placeholder {
            text-align: center;
            padding: 60px 20px;
            background: var(--preview-bg);
            border: 3px dashed var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 380px;
            /* 将最小高度移动到占位符上 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-placeholder:hover {
            border-color: var(--border-glow);
            background: var(--input-focus-bg);
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 72px;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        .upload-text {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .upload-hint {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        .upload-btn {
            padding: 16px 40px;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.5);
        }

        .crop-container {
            animation: fadeIn 0.5s ease;
        }

        .crop-canvas-wrapper {
            position: relative;
            /* 突破父级 padding 限制，撑满整个卡片宽度 */
            margin-left: calc(var(--card-padding) * -1);
            margin-right: calc(var(--card-padding) * -1);
            width: calc(100% + var(--card-padding) * 2);
            max-width: none;

            margin-bottom: 24px;
            /* 移除自身的圆角，依靠卡片的 overflow:hidden 来裁切圆角，或者保留直角 */
            border-radius: 0;
            overflow: hidden;
            background: #000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .crop-canvas-wrapper::-webkit-scrollbar {
            display: none;
        }

        #cropCanvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }

        .crop-box {
            position: absolute;
            border: 2px solid #fff;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5), inset 0 0 0 1px rgba(0, 0, 0, 0.3);
            cursor: move;
        }

        .crop-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #fff;
            border: 2px solid #667eea;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .crop-handle-nw {
            top: -8px;
            left: -8px;
            cursor: nw-resize;
        }

        .crop-handle-ne {
            top: -8px;
            right: -8px;
            cursor: ne-resize;
        }

        .crop-handle-sw {
            bottom: -8px;
            left: -8px;
            cursor: sw-resize;
        }

        .crop-handle-se {
            bottom: -8px;
            right: -8px;
            cursor: se-resize;
        }

        .crop-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .crop-grid-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.25);
        }

        .crop-grid-v {
            width: 1px;
            height: 100%;
            top: 0;
        }

        .crop-grid-v:nth-child(1) {
            left: 33.333%;
        }

        .crop-grid-v:nth-child(2) {
            left: 66.666%;
        }

        .crop-grid-h {
            width: 100%;
            height: 1px;
            left: 0;
        }

        .crop-grid-h:nth-child(3) {
            top: 33.333%;
        }

        .crop-grid-h:nth-child(4) {
            top: 66.666%;
        }

        .crop-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin-top: 24px;
            flex-wrap: wrap;
        }

        .crop-controls .crop-action-btn {
            min-width: 140px;
            padding: 12px 20px;
            font-size: 14px;
        }

        .crop-action-btn {
            flex: 1;
            min-width: 150px;
            padding: 16px 24px;
            border: none;
            border-radius: 16px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .crop-btn-primary {
            background: var(--primary-gradient);
            color: white;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .crop-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.5);
        }

        .crop-btn-secondary {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 4px 16px rgba(79, 172, 254, 0.3);
        }

        .crop-btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(79, 172, 254, 0.5);
        }

        .crop-btn-danger {
            background: var(--danger-gradient);
            color: white;
            box-shadow: 0 4px 16px rgba(250, 112, 154, 0.3);
        }

        .crop-btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(250, 112, 154, 0.5);
        }

        .crop-btn-success {
            background: var(--success-gradient);
            color: white;
            box-shadow: 0 4px 16px rgba(67, 233, 123, 0.3);
        }

        .crop-btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(67, 233, 123, 0.5);
        }

        .crop-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            padding: 20px;
            background: var(--preview-bg);
            border-radius: 16px;
        }

        .crop-info-item {
            text-align: center;
        }

        .crop-info-label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            font-weight: 600;
        }

        .dark-theme .crop-info-label {
            color: var(--text-primary);
            opacity: 0.9;
        }

        .crop-info-value {
            display: block;
            font-size: 18px;
            font-weight: 800;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dark-theme .crop-info-value {
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.2));
        }

        .crop-result {
            grid-column: span 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 确保子项整体居中 */
        }

        .crop-result-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 24px;
            background: var(--success-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            width: 100%;
        }

        .crop-result-preview {
            background: var(--preview-bg);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            width: 100%;
            /* 撑满容器 */
        }

        #resultCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        .crop-result-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* 开发者社交信息卡片 */
        .developer-card {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 1000;
            background: var(--card-bg-gradient);
            border-radius: 24px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 280px;
        }

        .developer-card:hover {
            box-shadow: var(--card-hover-shadow);
            transform: translateY(-2px);
        }

        .dev-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .dev-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            object-fit: cover;
            transition: all 0.3s ease;
        }

        .dev-avatar:hover {
            transform: scale(1.1);
            border-color: var(--border-glow);
        }

        .dev-info {
            flex: 1;
        }

        .dev-name {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .dev-title {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .social-links {
            display: grid;
            gap: 8px;
        }

        .social-link {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--input-bg);
            border-radius: 12px;
            text-decoration: none;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
        }

        .social-link:hover {
            background: var(--accent-gradient);
            color: white;
            transform: translateX(4px);
            border-color: rgba(0, 113, 227, 0.3);
            box-shadow: 0 4px 12px rgba(0, 113, 227, 0.2);
        }

        .social-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .social-text {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 微信二维码弹窗 */
        .qr-trigger {
            cursor: pointer;
            position: relative;
        }

        .qr-popup {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            margin-left: 12px;
            background: var(--card-bg-gradient);
            border-radius: 16px;
            padding: 16px;
            border: 1px solid var(--border-color);
            box-shadow: var(--card-hover-shadow);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 1001;
            animation: fadeIn 0.3s ease;
        }

        .qr-trigger:hover .qr-popup {
            display: block;
        }

        .qr-image {
            width: 180px;
            height: 180px;
            border-radius: 12px;
            display: block;
        }

        .qr-label {
            text-align: center;
            margin-top: 12px;
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        /* 收起/展开按钮 */
        .dev-toggle {
            text-align: center;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .toggle-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .toggle-btn:hover {
            background: var(--input-bg);
            color: var(--text-primary);
        }

        .developer-card.collapsed {
            max-width: 90px;
            padding: 16px;
        }

        .developer-card.collapsed .dev-header {
            flex-direction: column;
            margin-bottom: 0;
        }

        .developer-card.collapsed .dev-info,
        .developer-card.collapsed .social-links,
        .developer-card.collapsed .dev-toggle {
            display: none;
        }

        .developer-card.collapsed .dev-avatar {
            width: 56px;
            height: 56px;
        }

        /* 响应式 */
        @media (max-width: 968px) {
            .controls-bar {
                top: 20px;
                right: 20px;
            }

            .developer-card {
                top: 20px;
                left: 20px;
            }

            .main-content {
                grid-template-columns: 1fr;
            }

            .calculator-section {
                grid-column: span 1;
            }

            .ratio-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .header h1 {
                font-size: 36px;
            }
        }

        @media (max-width: 640px) {
            .theme-toggle {
                top: 15px;
                right: 15px;
            }

            .theme-btn {
                padding: 10px 16px;
                font-size: 12px;
            }

            .header h1 {
                font-size: 32px;
            }

            .card {
                --card-padding: 24px;
                padding: var(--card-padding);
                border-radius: 24px;
            }

            .input-row {
                grid-template-columns: 1fr;
            }

            .arrow-icon {
                transform: rotate(90deg);
            }
        }

        /* 图片拼接样式 */
        .stitch-container {
            padding: 24px;
        }

        .stitch-options {
            margin-bottom: 24px;
        }

        .stitch-mode-group {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stitch-mode-label {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stitch-mode-options {
            display: flex;
            gap: 12px;
        }

        .stitch-mode-option {
            cursor: pointer;
        }

        .stitch-mode-option input {
            display: none;
        }

        .stitch-mode-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: var(--input-bg);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stitch-mode-btn small {
            font-size: 11px;
            opacity: 0.7;
            font-weight: 500;
        }

        .stitch-mode-btn .stitch-icon {
            font-size: 18px;
        }

        .stitch-mode-option input:checked+.stitch-mode-btn {
            background: var(--primary-gradient);
            border-color: transparent;
            color: white;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .stitch-mode-option:hover .stitch-mode-btn:not(input:checked + *) {
            border-color: var(--border-glow);
            background: var(--input-focus-bg);
        }

        .stitch-image-list {
            display: flex;
            gap: 16px;
            padding: 20px;
            background: var(--preview-bg);
            border-radius: 20px;
            min-height: 120px;
            overflow-x: auto;
            flex-wrap: wrap;
        }

        .stitch-image-item {
            position: relative;
            flex-shrink: 0;
            animation: fadeIn 0.4s ease;
        }

        .stitch-image-thumb {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 12px;
            border: 3px solid var(--border-color);
            cursor: grab;
            transition: all 0.3s ease;
        }

        /* 仅在支持 Hover 的设备（PC）上启用悬停效果 */
        @media (hover: hover) {
            .stitch-image-thumb:hover {
                border-color: var(--border-glow);
                transform: scale(1.05);
            }
        }

        .stitch-image-thumb.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .stitch-image-info {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--card-bg-gradient);
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 700;
            color: var(--text-primary);
            white-space: nowrap;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(10px);
        }

        .stitch-image-remove {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 28px;
            height: 28px;
            background: var(--danger-gradient);
            border: 2px solid var(--card-bg);
            border-radius: 50%;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            opacity: 0;
        }

        @media (hover: hover) {
            .stitch-image-item:hover .stitch-image-remove {
                opacity: 1;
            }

            .stitch-image-remove:hover {
                transform: scale(1.15);
            }
        }

        /* 移动端/触摸屏优化：始终显示删除按钮，禁用Hover干扰 */
        @media (hover: none) {
            .stitch-image-remove {
                opacity: 1 !important;
                background: rgba(255, 59, 48, 0.9);
                width: 28px;
                /* 稍微加大触摸区域 */
                height: 28px;
            }
        }

        .stitch-image-order {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 28px;
            height: 28px;
            background: var(--accent-gradient);
            border: 2px solid var(--card-bg);
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stitch-preview-info {
            margin-top: 20px;
            padding: 16px 20px;
            background: var(--success-bg);
            border-radius: 16px;
            text-align: center;
        }

        .stitch-preview-text {
            font-size: 15px;
            font-weight: 600;
            color: var(--success-text);
        }

        .stitch-preview-text span {
            font-weight: 800;
            font-size: 18px;
        }

        .stitch-actions {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin-top: 32px;
            width: 100%;
            flex-wrap: wrap;
        }

        /* 针对拼接动作按钮的微调 */
        .stitch-actions .crop-action-btn {
            min-width: 140px;
            padding: 12px 20px;
            font-size: 14px;
        }

        @media (min-width: 768px) {
            .stitch-actions {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .stitch-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            color: var(--text-light);
            font-size: 14px;
            font-weight: 500;
        }

        .stitch-placeholder-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .stitch-image-item.selected .stitch-image-thumb {
            border-color: var(--primary-gradient);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .stitch-image-item.selected .stitch-image-order {
            background: var(--primary-gradient);
        }

        .stitch-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--text-light);
            font-weight: 800;
        }

        /* 拼接预览容器 */
        .stitch-preview-container {
            margin-bottom: 24px;
            padding: 20px;
            background: var(--preview-bg);
            border-radius: 20px;
            border: 2px solid var(--border-color);
        }

        .stitch-preview-label {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-align: center;
        }

        .stitch-preview-canvas {
            width: 100%;
            max-height: 400px;
            object-fit: contain;
            border-radius: 12px;
            background: var(--card-bg);
        }

        /* 小上传框 */
        .upload-placeholder-small {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background: var(--input-bg);
            border: 2px dashed var(--border-color);
            border-radius: 16px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-placeholder-small:hover {
            border-color: var(--border-glow);
            background: var(--input-focus-bg);
        }

        .upload-icon-small {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .upload-text-small {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .upload-btn-small {
            padding: 8px 20px;
            background: var(--primary-gradient);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-btn-small:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* 移动端专属优化 - 解决遮挡和拥挤问题 */
        @media (max-width: 968px) {
            body {
                display: flex;
                /* 改为 Flex 布局以调整顺序 */
                flex-direction: column;
                padding: 0;
                /* 接管 padding */
                background-attachment: fixed;
            }

            /* 1. 调整控制栏 (主题/语言切换) */
            /* 移至顶部文档流，不再悬浮遮挡 */
            .controls-bar {
                position: static;
                order: 0;
                width: 100%;
                justify-content: flex-end;
                /* 居右显示 */
                padding: 16px 24px;
                background: transparent;
                height: auto;
                margin-bottom: 0;
            }

            /* 2. 主内容区域 */
            .container {
                order: 1;
                width: 100%;
                max-width: 100%;
                padding: 10px 20px 40px 20px;
                margin: 0;
            }

            /* 3. 开发者卡片 - 移至底部 Footer */
            .developer-card {
                position: static;
                order: 2;
                /* 放在最底部 */
                width: 100%;
                max-width: 100%;
                margin: 20px 0 0 0;
                border-radius: 0;
                border: none;
                border-top: 1px solid var(--border-color);
                background: var(--card-bg-gradient);
                box-shadow: none;
                padding: 32px 24px 60px 24px;
                /* 底部留多一点空间 */
            }

            /* 移动端强制展开开发者信息，并不再支持收起（因为已经在底部了） */
            .developer-card.collapsed {
                max-width: 100%;
                padding: 32px 24px 60px 24px;
            }

            .developer-card .dev-toggle {
                display: none !important;
            }

            .developer-card.collapsed .dev-info,
            .developer-card.collapsed .social-links {
                display: block !important;
            }

            .developer-card.collapsed .dev-header {
                flex-direction: row;
                margin-bottom: 16px;
            }

            /* 社交链接横向自适应排列 */
            .social-links {
                display: grid !important;
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 12px;
            }

            /* 4. 解决模块拥挤问题 */
            .main-content {
                display: flex;
                flex-direction: column;
                gap: 32px;
                /* 增加模块间距 */
                margin-bottom: 0;
            }

            .card {
                padding: 24px 20px;
                /* 调整卡片内边距 */
            }

            /* 输入框组优化 */
            .input-row {
                gap: 16px;
            }

            /* 头部字体自适应 */
            .header {
                margin-bottom: 32px;
                padding: 0 10px;
            }

            .header h1 {
                font-size: 32px;
            }


            /* 比例选择按钮优化 */
            .ratio-grid {
                gap: 12px;
            }

            .ratio-btn {
                padding: 16px 8px;
                /* 减小内边距 */
            }

            /* 裁切区域优化 */
            .file-upload-label {
                padding: 40px 20px;
            }

            /* 预览和结果区域优化 padding */
            .crop-container,
            .stitch-container {
                padding: 16px;
            }

            /* 修正移动端二维码弹窗位置 - 显示在上方居中 */
            .qr-popup {
                left: 50% !important;
                top: auto !important;
                bottom: 100% !important;
                margin-left: 0 !important;
                margin-bottom: 12px;
                transform: translateX(-50%);
                z-index: 100;
            }

            /* 5. 按钮组优化 - 修复溢出和对齐问题 */
            /* 统一将所有主要操作区域改为双列网格布局，确保排版整齐且不溢出 */
            .crop-result-actions,
            .crop-controls,
            .stitch-actions {
                display: grid !important;
                grid-template-columns: repeat(2, 1fr) !important;
                /* 强制两列 */
                gap: 12px;
                width: 100%;
                justify-content: stretch;
                flex-wrap: wrap !important;
                /* 覆盖可能存在的flex-wrap */
            }

            /* 按钮样式复写：填满网格单元，高度拉伸对齐 */
            .crop-action-btn,
            .stitch-actions .crop-action-btn {
                min-width: 0 !important;
                /* 解除最小宽度限制 */
                width: 100% !important;
                padding: 12px 6px;
                /* 稍微减小Padding以防文字太多 */
                height: 100%;
                /* 确保在Grid中占满高度，实现等高 */
                white-space: normal;
                /* 允许文字换行 */
                line-height: 1.3;
                text-align: center;
            }

            /* 拼接模式选项优化 */
            .stitch-mode-group {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                width: 100%;
            }

            .stitch-mode-options {
                width: 100%;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .stitch-mode-btn {
                justify-content: center;
                width: 100%;
                text-align: center;
                /* 改为垂直堆叠，解决文字挤压难看的问题 */
                flex-direction: column !important;
                gap: 6px;
                padding: 14px 8px;
            }

            .stitch-mode-btn .stitch-icon {
                font-size: 22px;
                margin-bottom: 2px;
            }

            .stitch-mode-btn>span:not(.stitch-icon) {
                white-space: nowrap;
                /* 防止 "左右拼接" 换行 */
            }

            .stitch-mode-btn small {
                white-space: nowrap;
                /* 防止 "(高度对齐)" 换行 */
                display: block;
            }
        }

        @media (max-width: 640px) {
            .controls-bar {
                justify-content: center;
                /* 手机端居中可能更好看 */
                padding: 12px 16px;
            }

            .header h1 {
                font-size: 26px;
                line-height: 1.3;
            }

            .header p {
                font-size: 14px;
                padding: 0 20px;
                line-height: 1.5;
            }

            /* 移动端扩图占位符优化 */
            .outpainting-placeholder {
                padding: 20px 24px;
                border-radius: 24px;
                gap: 10px;
            }

            .outpainting-placeholder .placeholder-icon-wrap {
                width: 48px;
                height: 48px;
                border-radius: 16px;
            }

            .outpainting-placeholder .placeholder-icon-wrap svg {
                width: 20px;
                height: 20px;
            }

            .outpainting-placeholder .placeholder-text {
                font-size: 16px;
            }

            .outpainting-placeholder .placeholder-hint {
                font-size: 12px;
                line-height: 1.4;
            }

            /* 再次微调小屏幕的间距 */
            .ratio-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* 顶部工具栏 Tabs 样式 */
        .header-icon {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 24px;
        }

        .tool-icon-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 16px;
            transition: all 0.3s ease;
            opacity: 0.6;
            background: transparent;
        }

        .tool-icon-btn:hover {
            opacity: 0.8;
            background: rgba(0, 0, 0, 0.03);
            transform: translateY(-2px);
        }

        .tool-icon-btn.active {
            opacity: 1;
            background: rgba(0, 0, 0, 0.05);
            transform: translateY(0);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .tool-icon-btn svg {
            width: 48px;
            height: 48px;
            margin-bottom: 4px;
            filter: grayscale(100%);
            /* 默认灰色 */
            transition: all 0.3s ease;
        }

        .tool-icon-btn.active svg,
        .tool-icon-btn:hover svg {
            filter: grayscale(0);
            /* 激活或悬停时彩色 */
        }

        .tool-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .tool-icon-btn.active .tool-label {
            color: var(--text-primary);
        }

        /* 扩图底板交互层样式 */
        .outpainting-overlay {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .outpainting-overlay .outpainting-item {
            cursor: grab;
            position: absolute;
            user-select: none;
            touch-action: none;
            transform-origin: center center;
        }

        .outpainting-overlay .outpainting-item img {
            display: block;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .outpainting-overlay .outpainting-item:active {
            cursor: grabbing;
        }

        /* 选中状态的边框与手柄 */
        .outpainting-overlay .outpainting-item.active {
            outline: 2px dashed #3b82f6 !important;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.4);
            z-index: 100;
        }

        /* 精致缩放手柄 (NW, NE, SW, SE) */
        .outpainting-overlay .outpainting-item .op-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: white !important;
            border: 2px solid #3b82f6 !important;
            border-radius: 50% !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 101;
            display: none;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .outpainting-overlay .outpainting-item.active .op-handle {
            display: block;
        }

        .outpainting-overlay .outpainting-item .op-handle:hover {
            transform: scale(1.3);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .op-handle-nw {
            top: -7px;
            left: -7px;
        }

        .op-handle-ne {
            top: -7px;
            right: -7px;
        }

        .op-handle-sw {
            bottom: -7px;
            left: -7px;
        }

        .op-handle-se {
            bottom: -7px;
            right: -7px;
        }

        /* 现代浮动旋转徽章 (Modern Floating Rotation Badge) */
        .outpainting-overlay .outpainting-item.active .op-handle-rot {
            display: flex !important;
            position: absolute;
            width: 32px;
            height: 32px;
            top: -40px;
            /* 浮动在图片上方，无需连接杆 */
            left: 50%;
            margin-left: -16px;
            cursor: grab;

            /* 毛玻璃质感 - 现代感十足 */
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1.5px solid rgba(59, 130, 246, 0.3) !important;
            border-radius: 50% !important;

            align-items: center;
            justify-content: center;
            z-index: 120;

            /* 清晰的循环箭头图标 - 通用旋转符号 */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 2v6h-6M3 12a9 9 0 0 1 15-6.7L21 8M3 22v-6h6M21 12a9 9 0 0 1-15 6.7L3 16'/%3E%3C/svg%3E") !important;
            background-repeat: no-repeat !important;
            background-position: center !important;
            background-size: 18px 18px !important;

            /* 柔和阴影 + 微妙发光 */
            box-shadow:
                0 4px 12px rgba(0, 0, 0, 0.08),
                0 0 0 4px rgba(59, 130, 246, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);

            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);

            /* 微妙的脉动动画 - 提示可交互 */
            animation: rotationPulse 2s ease-in-out infinite;
        }

        @keyframes rotationPulse {

            0%,
            100% {
                box-shadow:
                    0 4px 12px rgba(0, 0, 0, 0.08),
                    0 0 0 4px rgba(59, 130, 246, 0.08),
                    inset 0 1px 0 rgba(255, 255, 255, 0.8);
            }

            50% {
                box-shadow:
                    0 4px 12px rgba(0, 0, 0, 0.08),
                    0 0 0 6px rgba(59, 130, 246, 0.15),
                    inset 0 1px 0 rgba(255, 255, 255, 0.8);
            }
        }

        .outpainting-overlay .outpainting-item.active .op-handle-rot:hover {
            transform: scale(1.15);
            background: rgba(255, 255, 255, 1) !important;
            border-color: #3b82f6 !important;
            box-shadow:
                0 8px 20px rgba(59, 130, 246, 0.2),
                0 0 0 6px rgba(59, 130, 246, 0.12);
            animation: none;
            /* 停止脉动 */
        }

        .outpainting-overlay .outpainting-item.active .op-handle-rot:active {
            cursor: grabbing;
            transform: scale(0.95);
            background: rgba(239, 246, 255, 1) !important;
        }

        /* 当未激活时完全隐藏所有手柄组件 */
        .outpainting-overlay .outpainting-item:not(.active) .op-handle,
        .outpainting-overlay .outpainting-item:not(.active) .op-handle-rot {
            display: none !important;
        }

        /* 扩图底板占位符美化 - 极致毛玻璃设计 */
        .outpainting-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            padding: 24px;
            border-radius: 50%;
            /* 圆形符号 */
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
        }

        .dark-theme .outpainting-placeholder {
            background: rgba(28, 28, 30, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .outpainting-placeholder:hover {
            background: rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%) scale(1.15);
            box-shadow: 0 15px 50px rgba(102, 126, 234, 0.3);
        }

        .dark-theme .outpainting-placeholder:hover {
            background: rgba(44, 44, 46, 0.75);
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.5);
        }

        .outpainting-placeholder .placeholder-icon-wrap {
            width: 72px;
            height: 72px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary-gradient);
            border-radius: 24px;
            color: white;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .outpainting-placeholder:hover .placeholder-icon-wrap {
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 12px 32px rgba(102, 126, 234, 0.45);
        }

        .outpainting-placeholder .placeholder-text {
            font-size: 20px;
            font-weight: 800;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dark-theme .outpainting-placeholder .placeholder-text {
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .outpainting-placeholder .placeholder-hint {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
            opacity: 0.8;
            line-height: 1.5;
        }
    </style>
</head>



<body>
    <!-- 开发者社交信息卡片 -->
    <div class="developer-card" id="devCard">
        <div class="dev-header">
            <a href="https://toolbuddy.art/" target="_blank" title="Visit ToolBuddy.art" id="devAvatarLink">
                <img src="avatar.png" alt="ToolBuddy" class="dev-avatar" id="devAvatar">
            </a>
            <div class="dev-info">
                <div class="dev-name" data-i18n="developer.name">工具狂</div>
                <div class="dev-title" data-i18n="developer.title">Developer</div>
            </div>
        </div>

        <div class="social-links">
            <a href="https://www.youtube.com/@crazytoolman" target="_blank" class="social-link">
                <span class="social-icon">▶️</span>
                <span class="social-text">YouTube</span>
            </a>

            <a href="https://toolbuddy.art/" target="_blank" class="social-link">
                <span class="social-icon">🌍</span>
                <span class="social-text">toolbuddy.art</span>
            </a>

            <a href="https://space.bilibili.com/33410454" target="_blank" class="social-link">
                <span class="social-icon">📺</span>
                <span class="social-text">Bilibili</span>
            </a>

            <a href="https://v.douyin.com/ik9R5bMW" target="_blank" class="social-link">
                <span class="social-icon">🎵</span>
                <span class="social-text" data-i18n="developer.douyin">抖音</span>
            </a>

            <div class="social-link qr-trigger">
                <span class="social-icon">💬</span>
                <span class="social-text" data-i18n="developer.wechat">微信公众号</span>
                <div class="qr-popup">
                    <img src="wechat_qr.png" alt="WeChat QR" class="qr-image" id="wechatQR">
                    <div class="qr-label" data-i18n="developer.scanQR">扫码关注</div>
                </div>
            </div>

            <div class="social-link" style="cursor: default; background: var(--preview-bg);">
                <span class="social-icon">👤</span>
                <span class="social-text" style="font-size: 12px;">crazytoolman</span>
            </div>
        </div>

        <div class="dev-toggle">
            <button class="toggle-btn" id="toggleDevCard" data-i18n="developer.collapse">收起</button>
        </div>
    </div>

    <!-- 控制栏 - 主题和语言 -->
    <div class="controls-bar">
        <!-- 主题切换器 -->
        <div class="theme-toggle">
            <button class="theme-btn active" data-theme="light">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
                <span data-i18n="theme.light">浅色</span>
            </button>
            <button class="theme-btn" data-theme="dark">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
                <span data-i18n="theme.dark">深色</span>
            </button>
        </div>
        <!-- 语言切换器 -->
        <div class="lang-toggle">
            <button class="lang-btn active" data-lang="zh">
                中文
            </button>
            <button class="lang-btn" data-lang="en">
                English
            </button>
        </div>
    </div>

    <div class="container">
        <!-- 头部 -->
        <div class="header">
            <div class="header-icon" id="toolTabs">
                <!-- 裁切与拼接模式 (橙色 + 紫色) - 默认激活 -->
                <div class="tool-icon-btn active" data-tool="image-tool" title="图像裁切/拼接"
                    data-i18n-title="nav.cropStitch">
                    <svg class="header-svg" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="icon-grad-merged" x1="0" y1="0" x2="48" y2="48"
                                gradientUnits="userSpaceOnUse">
                                <stop offset="0%" stop-color="#FF2D55" />
                                <stop offset="50%" stop-color="#FF9500" />
                                <stop offset="100%" stop-color="#AF52DE" />
                            </linearGradient>
                        </defs>
                        <!-- 裁切边框背景 (弱化) -->
                        <path d="M10 34V10C10 7.79086 11.7909 6 14 6H38" stroke="url(#icon-grad-merged)"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.5" />
                        <path d="M34 14V38C34 40.2091 32.2091 42 30 42H6" stroke="url(#icon-grad-merged)"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.5" />

                        <!-- 核心裁切框 (强化) -->
                        <path d="M16 32V16C16 13.7909 17.7909 12 20 12H36" stroke="url(#icon-grad-merged)"
                            stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" />
                        <path d="M32 16V32C32 34.2091 30.2091 36 28 36H12" stroke="url(#icon-grad-merged)"
                            stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" />

                        <!-- 拼接元素 (小矩形) -->
                        <rect x="36" y="24" width="8" height="12" rx="1.5" stroke="url(#icon-grad-merged)"
                            stroke-width="2.5" />
                        <path d="M32 30H36" stroke="url(#icon-grad-merged)" stroke-width="2" stroke-dasharray="1 2" />
                    </svg>
                    <div class="tool-label" data-i18n="nav.cropStitch">图像裁切/拼接</div>
                </div>

                <!-- 扩图/底板模式 (蓝色) -->
                <div class="tool-icon-btn" data-tool="outpainting" title="扩图底板" data-i18n-title="nav.outpainting">
                    <svg class="header-svg" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="icon-grad-1" x1="0" y1="0" x2="48" y2="48"
                                gradientUnits="userSpaceOnUse">
                                <stop offset="0%" stop-color="#0066FF" />
                                <stop offset="100%" stop-color="#5AC8FA" />
                            </linearGradient>
                        </defs>
                        <rect x="8" y="8" width="32" height="32" rx="6" stroke="url(#icon-grad-1)" stroke-width="3"
                            stroke-linecap="round" stroke-linejoin="round" />
                        <path d="M16 32L32 16" stroke="url(#icon-grad-1)" stroke-width="3" stroke-linecap="round"
                            stroke-linejoin="round" />
                        <path d="M32 16H24" stroke="url(#icon-grad-1)" stroke-width="3" stroke-linecap="round"
                            stroke-linejoin="round" />
                        <path d="M32 16V24" stroke="url(#icon-grad-1)" stroke-width="3" stroke-linecap="round"
                            stroke-linejoin="round" />
                        <path d="M16 32H24" stroke="url(#icon-grad-1)" stroke-width="3" stroke-linecap="round"
                            stroke-linejoin="round" />
                        <path d="M16 32V24" stroke="url(#icon-grad-1)" stroke-width="3" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                    <div class="tool-label" data-i18n="nav.outpainting">扩图底板</div>
                </div>
            </div>
            <h1 data-i18n="header.title">全能比例工具箱：计算 · 裁切 · 拼接 · 扩图</h1>
            <p data-i18n="header.subtitle">智能计算比例，并对图片进行精确裁切、拼合与扩图底板处理</p>
        </div>

        <!-- 主内容区 -->
        <div class="main-content">
            <!-- 图像裁切 -->
            <div class="card image-crop-section">
                <h2 class="card-title" data-i18n="imageCrop.title">图像裁切与拼接工具</h2>

                <!-- 上传区域 -->
                <div class="upload-area" id="uploadArea">
                    <input type="file" id="imageInput" accept="image/*" multiple style="display: none;">
                    <div class="upload-placeholder" id="uploadPlaceholder">
                        <div class="upload-icon">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                        </div>
                        <div class="upload-text" data-i18n="imageCrop.uploadText">点击上传、拖拽或粘贴图片到这里</div>
                        <div class="upload-hint" data-i18n="imageCrop.uploadHint">支持 JPG、PNG、GIF 等格式（可粘贴多张）</div>
                        <button class="upload-btn" id="uploadBtn" data-i18n="imageCrop.uploadBtn">选择图片</button>
                    </div>

                    <!-- 图片拼接区域 -->
                    <div class="stitch-container" id="stitchContainer" style="display: none;">
                        <!-- 拼接模式选择 -->
                        <div class="stitch-options">
                            <div class="stitch-mode-group">
                                <label class="stitch-mode-label" data-i18n="stitch.mode">拼接方式：</label>
                                <div class="stitch-mode-options">
                                    <label class="stitch-mode-option">
                                        <input type="radio" name="stitchMode" value="horizontal" checked>
                                        <span class="stitch-mode-btn">
                                            <span class="stitch-icon">⬌</span>
                                            <span data-i18n="stitch.horizontal">左右拼接</span>
                                            <small data-i18n="stitch.horizontalHint">(高度对齐)</small>
                                        </span>
                                    </label>
                                    <label class="stitch-mode-option">
                                        <input type="radio" name="stitchMode" value="vertical">
                                        <span class="stitch-mode-btn">
                                            <span class="stitch-icon">⬍</span>
                                            <span data-i18n="stitch.vertical">上下拼接</span>
                                            <small data-i18n="stitch.verticalHint">(宽度对齐)</small>
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- 实时拼接预览 -->
                        <div class="stitch-preview-container">
                            <div class="stitch-preview-label" data-i18n="stitch.previewLabel">拼接预览</div>
                            <canvas id="stitchPreviewCanvas" class="stitch-preview-canvas"></canvas>
                            <div class="stitch-preview-info" id="stitchPreviewInfo"></div>
                        </div>

                        <!-- 图片列表 -->
                        <div class="stitch-image-list" id="stitchImageList"></div>

                        <!-- 上传框（在图片列表下方） -->
                        <div class="upload-placeholder-small" id="uploadPlaceholderSmall">
                            <div class="upload-icon-small">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="17 8 12 3 7 8"></polyline>
                                    <line x1="12" y1="3" x2="12" y2="15"></line>
                                </svg>
                            </div>
                            <div class="upload-text-small" data-i18n="imageCrop.uploadTextSmall">继续添加图片</div>
                            <button class="upload-btn-small" id="uploadBtnSmall"
                                data-i18n="imageCrop.uploadBtn">选择图片</button>
                        </div>

                        <!-- 拼接按钮 -->
                        <div class="stitch-actions">
                            <button class="crop-action-btn crop-btn-primary" id="stitchBtn">
                                <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                        style="margin-right: 6px;">
                                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                                    </svg></span>
                                <span data-i18n="stitch.stitchBtn">拼接图片</span>
                            </button>
                            <button class="crop-action-btn crop-btn-success" id="downloadStitchBtn">
                                <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                        style="margin-right: 6px;">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="7 10 12 15 17 10"></polyline>
                                        <line x1="12" y1="15" x2="12" y2="3"></line>
                                    </svg></span>
                                <span data-i18n="stitch.downloadBtn">直接下载拼接图</span>
                            </button>
                            <button class="crop-action-btn crop-btn-primary" id="copyStitchBtn">
                                <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                        style="margin-right: 6px;">
                                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                    </svg></span>
                                <span data-i18n="stitch.copyBtn">直接复制拼接图</span>
                            </button>
                            <button class="crop-action-btn crop-btn-secondary" id="preCropBtn" style="display: none;">
                                <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                        style="margin-right: 6px;">
                                        <circle cx="6" cy="6" r="3"></circle>
                                        <circle cx="6" cy="18" r="3"></circle>
                                        <line x1="20" y1="4" x2="8.12" y2="15.88"></line>
                                        <line x1="14.47" y1="14.48" x2="20" y2="20"></line>
                                        <line x1="8.12" y1="8.12" x2="12" y2="12"></line>
                                    </svg></span>
                                <span data-i18n="stitch.preCropBtn">预裁切选中项</span>
                            </button>
                            <button class="crop-action-btn crop-btn-danger" id="clearStitchBtn">
                                <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                        style="margin-right: 6px;">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path
                                            d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                                        </path>
                                        <line x1="10" y1="11" x2="10" y2="17"></line>
                                        <line x1="14" y1="11" x2="14" y2="17"></line>
                                    </svg></span>
                                <span data-i18n="stitch.clearBtn">清空图片</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 扩图底板区域 -->
                <div class="outpainting-container" id="outpaintingContainer" style="display: none;">
                    <div class="outpainting-toolbar" style="margin-bottom: 20px; text-align: center;">
                        <div class="outpainting-hint-top" style="margin-bottom: 12px; animation: fadeIn 0.8s ease;">
                            <div class="placeholder-text" data-i18n="outpainting.placeholderText"
                                style="font-size: 19px; font-weight: 800; color: var(--text-primary); margin-bottom: 6px;">
                                点击上传、粘贴或拖拽图片</div>
                            <div class="placeholder-hint" data-i18n="outpainting.placeholderHint"
                                style="font-size: 13px; color: var(--text-secondary); line-height: 1.4; font-weight: 500;">
                                图片将悬浮于绿色底板上，支持自由拖拽、缩放与多图层操作</div>
                        </div>
                        <span
                            style="font-weight: 600; font-size: 14px; color: var(--text-secondary); background: var(--preview-bg); padding: 6px 16px; border-radius: 50px; border: 1px solid var(--border-color);">
                            <span data-i18n="outpainting.sizeLabel">底板尺寸:</span>
                            <span id="outpaintingSizeDisplay" style="color: var(--text-primary); margin-left: 4px;">-- x
                                --</span>
                        </span>
                    </div>

                    <div class="outpainting-canvas-wrapper" id="outpaintingWrapper"
                        style="position: relative; overflow: hidden; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 0 auto; background-color: #00FF00;">
                        <!-- 渲染用的 Canvas -->
                        <canvas id="outpaintingCanvas" style="display: block; width: 100%; height: 100%;"></canvas>

                        <!-- 交互层 -->
                        <div id="outpaintingOverlay" class="outpainting-overlay"
                            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;">
                            <div class="outpainting-placeholder" id="outpaintingPlaceholder">
                                <div class="placeholder-icon-wrap" style="width: 48px; height: 48px; box-shadow: none;">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="stitch-actions" style="margin-top: 20px;">
                        <button class="crop-action-btn crop-btn-success" id="confirmOutpaintingBtn">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg></span>
                            <span data-i18n="outpainting.confirmBtn">确认合成</span>
                        </button>
                        <button class="crop-action-btn crop-btn-secondary" id="cancelOutpaintingBtn"
                            style="display: none;">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <path d="M3 6h18"></path>
                                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                                </svg></span>
                            <span data-i18n="outpainting.cancelBtn">取消合成</span>
                        </button>
                        <button class="crop-action-btn crop-btn-primary" id="downloadOutpaintingBtn"
                            style="display: none;">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                    <polyline points="7 3 7 8 15 8"></polyline>
                                </svg></span>
                            <span data-i18n="outpainting.downloadBtn">下载结果</span>
                        </button>
                        <button class="crop-action-btn crop-btn-primary" id="copyOutpaintingBtn" style="display: none;">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg></span>
                            <span data-i18n="outpainting.copyBtn">复制图片</span>
                        </button>
                        <button class="crop-action-btn crop-btn-secondary" id="resetOutpaintingBtn">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <polyline points="23 4 23 10 17 10"></polyline>
                                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                                </svg></span>
                            <span data-i18n="outpainting.resetBtn">重置画布</span>
                        </button>
                    </div>
                    <input type="file" id="outpaintingInput" accept="image/*" style="display: none;">
                </div>

                <!-- 裁切区域 -->
                <div class="crop-container" id="cropContainer" style="display: none;">
                    <div class="crop-canvas-wrapper">
                        <!-- Zoom Controls Header -->
                        <div class="zoom-controls-header"
                            style="width: 100%; display: flex; justify-content: flex-end; align-items: center; gap: 8px; padding: 10px 16px; box-sizing: border-box; background: rgba(255,255,255,0.05); border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button id="zoomOutBtn" class="zoom-btn-small" title="Zoom Out">-</button>
                            <input type="number" id="zoomInput" class="zoom-input" value="100" min="10" max="5000">
                            <span style="color: white; font-size: 12px; margin-right: 4px;">%</span>
                            <button id="zoomInBtn" class="zoom-btn-small" title="Zoom In">+</button>
                        </div>
                        <div class="crop-content-layer" style="position: relative; width: fit-content; margin: 0 auto;">
                            <canvas id="cropCanvas"></canvas>
                            <div class="crop-overlay" id="cropOverlay">
                                <div class="crop-box" id="cropBox">
                                    <div class="crop-handle crop-handle-nw"></div>
                                    <div class="crop-handle crop-handle-ne"></div>
                                    <div class="crop-handle crop-handle-sw"></div>
                                    <div class="crop-handle crop-handle-se"></div>
                                    <!-- 圆角控制点 -->
                                    <div class="corner-radius-handle corner-radius-handle-top" data-edge="top"></div>
                                    <div class="corner-radius-handle corner-radius-handle-right" data-edge="right">
                                    </div>
                                    <div class="corner-radius-handle corner-radius-handle-bottom" data-edge="bottom">
                                    </div>
                                    <div class="corner-radius-handle corner-radius-handle-left" data-edge="left"></div>
                                    <div class="crop-grid">
                                        <div class="crop-grid-line crop-grid-v"></div>
                                        <div class="crop-grid-line crop-grid-v"></div>
                                        <div class="crop-grid-line crop-grid-h"></div>
                                        <div class="crop-grid-line crop-grid-h"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="crop-controls">
                        <button class="crop-action-btn crop-btn-primary" id="cropBtn">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <circle cx="6" cy="6" r="3"></circle>
                                    <circle cx="6" cy="18" r="3"></circle>
                                    <line x1="20" y1="4" x2="8.12" y2="15.88"></line>
                                    <line x1="14.47" y1="14.48" x2="20" y2="20"></line>
                                    <line x1="8.12" y1="8.12" x2="12" y2="12"></line>
                                </svg></span>
                            <span data-i18n="imageCrop.cropBtn">裁切图片</span>
                        </button>
                        <button class="crop-action-btn crop-btn-primary" id="applyPreCropBtn" style="display: none;">
                            <span data-i18n="stitch.savePreCrop">应用到列表并返回</span>
                        </button>
                        <button class="crop-action-btn crop-btn-secondary" id="rotateBtn">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <polyline points="23 4 23 10 17 10"></polyline>
                                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                                </svg></span>
                            <span data-i18n="imageCrop.rotate90Btn">旋转 90°</span>
                        </button>
                        <button class="crop-action-btn crop-btn-secondary" id="cancelStitchBtn" style="display: none;">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <line x1="19" y1="12" x2="5" y2="12"></line>
                                    <polyline points="12 19 5 12 12 5"></polyline>
                                </svg></span>
                            <span data-i18n="stitch.backToStitch">撤回并返回列表</span>
                        </button>
                        <button class="crop-action-btn crop-btn-secondary" id="resetCropBtn">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <polyline points="23 4 23 10 17 10"></polyline>
                                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                                </svg></span>
                            <span data-i18n="imageCrop.resetBtn">重置裁切区域</span>
                        </button>
                        <button class="crop-action-btn crop-btn-danger" id="cancelCropBtn">
                            <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                    style="margin-right: 6px;">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg></span>
                            <span data-i18n="imageCrop.cancelBtn">取消并重新上传</span>
                        </button>
                    </div>

                    <!-- 高级控制：旋转与圆角 -->
                    <div class="rotation-controls">
                        <span class="control-label" data-i18n="imageCrop.rotateLabel">旋转角度:</span>
                        <input type="range" id="rotationSlider" class="control-slider" min="-180" max="180" value="0">
                        <input type="number" id="rotationInput" class="control-input" min="-180" max="180" value="0">
                        <span class="control-label" style="min-width: unset;">°</span>
                    </div>

                    <div class="border-radius-controls">
                        <span class="control-label" data-i18n="imageCrop.borderRadiusLabel">圆角调节:</span>
                        <input type="range" id="borderRadiusSlider" class="control-slider" min="0" max="250" value="0">
                        <input type="number" id="borderRadiusInput" class="control-input" min="0" max="250" value="0">
                        <span class="control-label" style="min-width: unset;">px</span>
                    </div>

                    <!-- 裁切信息 -->
                    <div class="crop-info">
                        <div class="crop-info-item">
                            <span class="crop-info-label" data-i18n="imageCrop.originalSize">原始尺寸:</span>
                            <span class="crop-info-value" id="originalSize">—</span>
                        </div>
                        <div class="crop-info-item">
                            <span class="crop-info-label" data-i18n="imageCrop.cropArea">裁切区域:</span>
                            <span class="crop-info-value" id="cropSize">—</span>
                        </div>
                        <div class="crop-info-item">
                            <span class="crop-info-label" data-i18n="imageCrop.currentRatio">当前比例:</span>
                            <span class="crop-info-value" id="cropRatio">—</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 裁切结果 -->
            <div class="card crop-result" id="cropResult" style="display: none;">
                <h3 class="crop-result-title" data-i18n="imageCrop.resultTitle">裁切结果预览</h3>
                <div class="crop-result-preview">
                    <canvas id="resultCanvas"></canvas>
                </div>
                <div class="crop-result-actions">
                    <button class="crop-action-btn crop-btn-success" id="savePreCropBtn" style="display: none;">
                        <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                style="margin-right: 6px;">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg></span>
                        <span data-i18n="stitch.savePreCrop">应用到列表</span>
                    </button>
                    <button class="crop-action-btn crop-btn-success" id="downloadBtn">
                        <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                style="margin-right: 6px;">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                <polyline points="7 3 7 8 15 8"></polyline>
                            </svg></span>
                        <span data-i18n="imageCrop.downloadBtn">下载图片 (PNG)</span>
                    </button>
                    <button class="crop-action-btn crop-btn-primary" id="copyBtn">
                        <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                style="margin-right: 6px;">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg></span>
                        <span data-i18n="imageCrop.copyBtn">复制图片</span>
                    </button>
                    <button class="crop-action-btn crop-btn-secondary" id="newCropBtn">
                        <span><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                                style="margin-right: 6px;">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                            </svg></span>
                        <span data-i18n="imageCrop.newCropBtn">裁切新图片</span>
                    </button>
                </div>
            </div>
            <!-- 之前在这里多了一个闭合标签，已移除 -->

            <!-- 图像裁切专用的比例配置区域 -->
            <div id="cropRatioGroup" style="display: contents;">
                <!-- 选择比例 -->
                <div class="card" id="ratioSelectCard">
                    <h2 class="card-title" data-i18n="ratioSelect.title">选择比例</h2>

                    <div class="ratio-grid">
                        <button class="ratio-btn" data-ratio="2:3">
                            <div class="ratio-value">2:3</div>
                            <div class="ratio-label" data-i18n="ratioSelect.vertical">竖版照片</div>
                        </button>
                        <button class="ratio-btn" data-ratio="3:2">
                            <div class="ratio-value">3:2</div>
                            <div class="ratio-label" data-i18n="ratioSelect.horizontal">横版照片</div>
                        </button>
                        <button class="ratio-btn" data-ratio="1:1">
                            <div class="ratio-value">1:1</div>
                            <div class="ratio-label" data-i18n="ratioSelect.square">正方形</div>
                        </button>
                        <button class="ratio-btn" data-ratio="16:9">
                            <div class="ratio-value">16:9</div>
                            <div class="ratio-label" data-i18n="ratioSelect.widescreen">宽屏</div>
                        </button>
                        <button class="ratio-btn" data-ratio="9:16">
                            <div class="ratio-value">9:16</div>
                            <div class="ratio-label" data-i18n="ratioSelect.portrait">竖屏</div>
                        </button>
                        <button class="ratio-btn active" data-ratio="4:3">
                            <div class="ratio-value">4:3</div>
                            <div class="ratio-label" data-i18n="ratioSelect.traditional">传统屏幕</div>
                        </button>
                        <button class="ratio-btn" data-ratio="3:4">
                            <div class="ratio-value">3:4</div>
                            <div class="ratio-label" data-i18n="ratioSelect.verticalTraditional">竖版传统</div>
                        </button>
                        <button class="ratio-btn" data-ratio="21:9">
                            <div class="ratio-value">21:9</div>
                            <div class="ratio-label" data-i18n="ratioSelect.ultrawide">超宽屏</div>
                        </button>
                        <button class="ratio-btn" data-ratio="1:2">
                            <div class="ratio-value">1:2</div>
                            <div class="ratio-label" data-i18n="ratioSelect.tallImage">竖长图</div>
                        </button>
                        <button class="ratio-btn" data-ratio="4:5">
                            <div class="ratio-value">4:5</div>
                            <div class="ratio-label" data-i18n="ratioSelect.ratio45">4:5</div>
                        </button>
                        <button class="ratio-btn" data-ratio="5:4">
                            <div class="ratio-value">5:4</div>
                            <div class="ratio-label" data-i18n="ratioSelect.miniProgram">小程序封面</div>
                        </button>
                        <button class="ratio-btn" data-ratio="2.35:1">
                            <div class="ratio-value">2.35:1</div>
                            <div class="ratio-label" data-i18n="ratioSelect.wechatCover">微信封面</div>
                        </button>
                    </div>

                    <div class="custom-ratio">
                        <div class="custom-ratio-title" data-i18n="ratioSelect.custom">自定义比例</div>
                        <div class="custom-input-group">
                            <input type="number" id="customWidth" data-i18n-placeholder="ratioSelect.customWidth"
                                placeholder="宽" min="1">
                            <span class="separator">:</span>
                            <input type="number" id="customHeight" data-i18n-placeholder="ratioSelect.customHeight"
                                placeholder="高" min="1">
                        </div>
                    </div>
                </div>

                <!-- 比例预览 -->
                <div class="card preview-card" id="previewCard">
                    <h2 class="card-title" data-i18n="preview.title">比例预览</h2>
                    <p class="preview-subtitle" data-i18n="preview.subtitle">可视化显示当前选择的比例</p>

                    <div class="preview-container">
                        <div class="preview-box" id="previewBox">
                            <div class="preview-ratio-text" id="previewRatio">3:4</div>
                            <div class="preview-description" id="previewDesc">3 × 4</div>
                        </div>
                    </div>

                    <div class="result-display" id="resultDisplay" style="display: none;">
                        <div class="result-label" data-i18n="preview.resultLabel">计算结果</div>
                        <div class="result-value" id="resultValue">—</div>
                    </div>
                </div>

                <!-- 尺寸计算 -->
                <div class="card calculator-section">
                    <h2 class="card-title" data-i18n="calculator.title">尺寸计算</h2>

                    <div class="current-ratio">
                        <span data-i18n="calculator.currentRatio">当前比例：</span><span class="current-ratio-value"
                            id="currentRatioText">3:4</span>
                    </div>

                    <div class="input-groups">
                        <div class="input-row">
                            <div class="input-field">
                                <label for="inputWidth" data-i18n="calculator.inputWidth">输入宽度</label>
                                <input type="number" id="inputWidth" data-i18n-placeholder="calculator.widthPlaceholder"
                                    placeholder="输入宽度数值" step="0.01">
                            </div>
                            <div class="arrow-icon">➜</div>
                            <div class="input-field">
                                <label for="calcHeight" data-i18n="calculator.calcHeight">计算高度</label>
                                <input type="number" id="calcHeight" placeholder="—" class="calculated" readonly>
                            </div>
                        </div>

                        <div class="input-row">
                            <div class="input-field">
                                <label for="inputHeight" data-i18n="calculator.inputHeight">输入高度</label>
                                <input type="number" id="inputHeight"
                                    data-i18n-placeholder="calculator.heightPlaceholder" placeholder="输入高度数值"
                                    step="0.01">
                            </div>
                            <div class="arrow-icon">➜</div>
                            <div class="input-field">
                                <label for="calcWidth" data-i18n="calculator.calcWidth">计算宽度</label>
                                <input type="number" id="calcWidth" placeholder="—" class="calculated" readonly>
                            </div>
                        </div>
                    </div>

                    <button class="clear-btn" id="clearBtn" data-i18n="calculator.clearBtn">清空所有输入</button>
                </div>
            </div>

            <!-- 扩图专用比例配置区域 (保持物理隔离且布局紧凑) -->
            <div id="opRatioGroup" style="display: none;">
                <!-- 选择比例 (扩图) -->
                <div class="card" id="opRatioSelectCard">
                    <h2 class="card-title" data-i18n="ratioSelect.title">选择比例</h2>
                    <div class="ratio-grid" id="opRatioGrid">
                        <button class="ratio-btn" data-ratio="2:3">
                            <div class="ratio-value">2:3</div>
                            <div class="ratio-label" data-i18n="ratioSelect.vertical">竖版照片</div>
                        </button>
                        <button class="ratio-btn" data-ratio="3:2">
                            <div class="ratio-value">3:2</div>
                            <div class="ratio-label" data-i18n="ratioSelect.horizontal">横版照片</div>
                        </button>
                        <button class="ratio-btn" data-ratio="1:1">
                            <div class="ratio-value">1:1</div>
                            <div class="ratio-label" data-i18n="ratioSelect.square">正方形</div>
                        </button>
                        <button class="ratio-btn" data-ratio="16:9">
                            <div class="ratio-value">16:9</div>
                            <div class="ratio-label" data-i18n="ratioSelect.widescreen">宽屏</div>
                        </button>
                        <button class="ratio-btn" data-ratio="9:16">
                            <div class="ratio-value">9:16</div>
                            <div class="ratio-label" data-i18n="ratioSelect.portrait">竖屏</div>
                        </button>
                        <button class="ratio-btn active" data-ratio="4:3">
                            <div class="ratio-value">4:3</div>
                            <div class="ratio-label" data-i18n="ratioSelect.traditional">传统屏幕</div>
                        </button>
                        <button class="ratio-btn" data-ratio="3:4">
                            <div class="ratio-value">3:4</div>
                            <div class="ratio-label" data-i18n="ratioSelect.verticalTraditional">竖版传统</div>
                        </button>
                        <button class="ratio-btn" data-ratio="21:9">
                            <div class="ratio-value">21:9</div>
                            <div class="ratio-label" data-i18n="ratioSelect.ultrawide">超宽屏</div>
                        </button>
                        <button class="ratio-btn" data-ratio="1:2">
                            <div class="ratio-value">1:2</div>
                            <div class="ratio-label" data-i18n="ratioSelect.tallImage">竖长图</div>
                        </button>
                        <button class="ratio-btn" data-ratio="4:5">
                            <div class="ratio-value">4:5</div>
                            <div class="ratio-label" data-i18n="ratioSelect.ratio45">4:5</div>
                        </button>
                        <button class="ratio-btn" data-ratio="5:4">
                            <div class="ratio-value">5:4</div>
                            <div class="ratio-label" data-i18n="ratioSelect.miniProgram">小程序封面</div>
                        </button>
                        <button class="ratio-btn" data-ratio="2.35:1">
                            <div class="ratio-value">2.35:1</div>
                            <div class="ratio-label" data-i18n="ratioSelect.wechatCover">微信封面</div>
                        </button>
                    </div>
                    <div class="custom-ratio">
                        <div class="custom-ratio-title" data-i18n="ratioSelect.custom">自定义比例</div>
                        <div class="custom-input-group">
                            <input type="number" id="opCustomWidth" data-i18n-placeholder="ratioSelect.customWidth"
                                placeholder="宽" min="1">
                            <span class="separator">:</span>
                            <input type="number" id="opCustomHeight" data-i18n-placeholder="ratioSelect.customHeight"
                                placeholder="高" min="1">
                        </div>
                    </div>
                </div>

                <!-- 比例预览 (扩图) -->
                <div class="card preview-card" id="opPreviewCard">
                    <h2 class="card-title" data-i18n="preview.title">比例预览</h2>
                    <div class="preview-container">
                        <div class="preview-box" id="opPreviewBox">
                            <div class="preview-ratio-text" id="opPreviewRatio">4:3</div>
                            <div class="preview-description" id="opPreviewDesc">4 × 3</div>
                        </div>
                    </div>
                    <div class="result-display" id="opResultDisplay" style="display: none;">
                        <div class="result-label" data-i18n="preview.resultLabel">底板计算结果</div>
                        <div class="result-value" id="opResultValue">—</div>
                    </div>
                </div>

                <!-- 尺寸计算 (扩图) -->
                <div class="card calculator-section" id="opCalculatorSection">
                    <h2 class="card-title" data-i18n="calculator.title">尺寸计算</h2>
                    <div class="current-ratio">
                        <span data-i18n="calculator.currentRatio">当前底板比例：</span><span class="current-ratio-value"
                            id="opCurrentRatioText">4:3</span>
                    </div>
                    <div class="input-groups">
                        <div class="input-row">
                            <div class="input-field">
                                <label for="opInputWidth" data-i18n="calculator.inputWidth">输入宽度</label>
                                <input type="number" id="opInputWidth"
                                    data-i18n-placeholder="calculator.widthPlaceholder" placeholder="输入宽度" step="0.01">
                            </div>
                            <div class="arrow-icon">➜</div>
                            <div class="input-field">
                                <label for="opCalcHeight" data-i18n="calculator.calcHeight">计算高度</label>
                                <input type="number" id="opCalcHeight" placeholder="—" class="calculated" readonly>
                            </div>
                        </div>
                        <div class="input-row">
                            <div class="input-field">
                                <label for="opInputHeight" data-i18n="calculator.inputHeight">输入高度</label>
                                <input type="number" id="opInputHeight"
                                    data-i18n-placeholder="calculator.heightPlaceholder" placeholder="输入高度" step="0.01">
                            </div>
                            <div class="arrow-icon">➜</div>
                            <div class="input-field">
                                <label for="opCalcWidth" data-i18n="calculator.calcWidth">计算宽度</label>
                                <input type="number" id="opCalcWidth" placeholder="—" class="calculated" readonly>
                            </div>
                        </div>
                    </div>
                    <button class="clear-btn" id="opClearBtn" data-i18n="calculator.clearBtn">清空配置</button>
                </div>
            </div>

            <!-- 使用说明 -->
            <div class="card instructions"> <!-- Added 'card' class and implicitly grid-column: span 2 via CSS -->
                <h3 data-i18n="instructions.title">使用说明：</h3>
                <p><strong data-i18n="instructions.ratioCalc">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="3" stroke-linecap="round" stroke-linejoin="round"
                            style="vertical-align: middle; margin-right: 4px;">
                            <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                            <path d="M2 17l10 5 10-5"></path>
                            <path d="M2 12l10 5 10-5"></path>
                        </svg>
                        比例计算：</strong><span
                        data-i18n="instructions.ratioCalcDesc">选择预设比例或输入自定义比例,然后在任意一个输入框中输入数值,系统将自动计算另一边的尺寸。</span></p>
                <p><strong data-i18n="instructions.imageCrop">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="3" stroke-linecap="round" stroke-linejoin="round"
                            style="vertical-align: middle; margin-right: 4px;">
                            <circle cx="6" cy="6" r="3"></circle>
                            <circle cx="6" cy="18" r="3"></circle>
                            <line x1="20" y1="4" x2="8.12" y2="15.88"></line>
                            <line x1="14.47" y1="14.48" x2="20" y2="20"></line>
                            <line x1="8.12" y1="8.12" x2="12" y2="12"></line>
                        </svg>
                        图像裁切：</strong><span
                        data-i18n="instructions.imageCropDesc">点击上传或拖拽图片到上传区域,选择合适的比例后,拖动裁切框或调整角落手柄来定位裁切区域,点击"裁切图片"按钮完成裁切,最后可以下载裁切结果。</span>
                </p>
                <p data-i18n="instructions.supported">支持的比例包括常用的照片比例、屏幕比例等,也可以自定义任意比例进行计算和裁切。</p>
            </div>

            <!-- 配置管理 -->
            <div class="card persistence-section" style="grid-column: span 2;">
                <h2 class="card-title" data-i18n="config.title">配置管理</h2>
                <div class="stitch-actions" style="margin-top: 10px;"> <!-- 复用居中样式 -->
                    <button class="crop-action-btn crop-btn-primary" id="saveConfigBtn">
                        <span data-i18n="config.saveBtn">保存当前配置</span>
                    </button>
                    <button class="crop-action-btn crop-btn-danger" id="clearConfigBtn">
                        <span data-i18n="config.clearBtn">清除所有配置并重置</span>
                    </button>
                </div>
            </div>
        </div>

        <footer
            style="text-align: center; padding: 40px 20px 20px; color: var(--text-secondary); font-size: 14px; font-weight: 500; opacity: 0.8;">
            © 2026 ToolBuddy. All Rights Reserved.
        </footer>
    </div>

    <script>
        const toolLabels = {
            'image-tool': { zh: '裁切与拼接管理', en: 'Crop & Stitch Manager' },
            outpainting: { zh: '扩图底板创作', en: 'Outpainting Creator' }
        };

        // ========== 国际化系统 ==========
        const translations = {
            zh: {
                nav: {
                    cropStitch: '图像裁切/拼接',
                    outpainting: '扩图底板'
                },
                theme: {
                    light: '浅色',
                    dark: '深色'
                },
                header: {
                    title: '全能比例工具箱：计算 · 裁切 · 拼接 · 扩图',
                    subtitle: '智能计算比例，并对图片进行精确裁切、拼合与扩图底板处理'
                },
                imageCrop: {
                    title: '图像裁切与拼接工具',
                    uploadText: '点击上传、拖拽或粘贴图片到这里',
                    uploadHint: '支持 JPG、PNG、GIF 等格式（可粘贴多张）',
                    uploadBtn: '选择图片',
                    uploadTextSmall: '继续添加图片',
                    cropBtn: '裁切图片',
                    rotate90Btn: '旋转 90°',
                    resetBtn: '重置裁切区域',
                    cancelBtn: '取消并重新上传',
                    originalSize: '原始尺寸:',
                    cropArea: '裁切区域:',
                    currentRatio: '裁切比例:',
                    rotateLabel: '旋转角度:',
                    borderRadiusLabel: '圆角调节:',
                    resultTitle: '裁切结果预览',
                    downloadBtn: '下载图片 (PNG)',
                    copyBtn: '复制图片',
                    copiedBtn: '已复制!',
                    newCropBtn: '裁切新图片'
                },
                stitch: {
                    mode: '拼接方式：',
                    horizontal: '左右拼接',
                    horizontalHint: '(高度对齐)',
                    vertical: '上下拼接',
                    verticalHint: '(宽度对齐)',
                    stitchBtn: '开始裁切流程',
                    clearBtn: '清空列表',
                    placeholder: '粘贴或上传多张图片',
                    previewLabel: '拼接预览',
                    dimensions: '总尺寸：',
                    preCropBtn: '预裁切选中项',
                    savePreCrop: '应用到列表并返回',
                    downloadBtn: '直接下载拼接图',
                    copyBtn: '直接复制拼接图',
                    backToStitch: '撤回并返回列表',
                    copied: '已复制！',
                    preview: '张图片'
                },
                config: {
                    title: '配置管理',
                    saveBtn: '保存当前配置',
                    clearBtn: '清除所有配置并重置',
                    saveSuccess: '配置已成功保存到本地！',
                    clearConfirm: '确定要清除所有配置并恢复原始状态吗？此操作不可撤销。'
                },
                ratioSelect: {
                    title: '选择比例',
                    vertical: '竖版照片',
                    horizontal: '横版照片',
                    square: '正方形',
                    widescreen: '宽屏',
                    portrait: '竖屏',
                    traditional: '传统屏幕',
                    verticalTraditional: '竖版传统',
                    ultrawide: '超宽屏',
                    tallImage: '竖长图',
                    ratio45: '4:5',
                    miniProgram: '小程序封面',
                    wechatCover: '微信封面',
                    custom: '自定义比例',
                    customWidth: '宽',
                    customHeight: '高'
                },
                preview: {
                    title: '比例预览',
                    subtitle: '可视化显示当前选择的比例',
                    resultLabel: '计算结果'
                },
                calculator: {
                    title: '尺寸计算',
                    currentRatio: '当前比例：',
                    inputWidth: '输入宽度',
                    inputHeight: '输入高度',
                    calcWidth: '计算宽度',
                    calcHeight: '计算高度',
                    widthPlaceholder: '输入宽度数值',
                    heightPlaceholder: '输入高度数值',
                    clearBtn: '清空所有输入'
                },
                instructions: {
                    title: '使用说明：',
                    ratioCalc: '比例计算：',
                    ratioCalcDesc: '选择预设比例或输入自定义比例,然后在任意一个输入框中输入数值,系统将自动计算另一边的尺寸。',
                    imageCrop: '图像裁切：',
                    imageCropDesc: '点击上传或拖拽图片到上传区域,选择合适的比例后,拖动裁切框或调整角落手柄来定位裁切区域,点击"裁切图片"按钮完成裁切,最后可以下载裁切结果。',
                    supported: '支持的比例包括常用的照片比例、屏幕比例等,也可以自定义任意比例进行计算和裁切。'
                },
                developer: {
                    name: '工具狂',
                    title: 'Developer',
                    douyin: '抖音',
                    wechat: '微信公众号',
                    scanQR: '扫码关注',
                    collapse: '收起',
                    expand: '展开'
                },
                outpainting: {
                    sizeLabel: '底板尺寸 (基于比例计算器):',
                    placeholderText: '点击上传、粘贴或拖拽图片',
                    placeholderHint: '图片将悬浮于绿色底板上，支持自由拖拽、缩放与多图层操作',
                    confirmBtn: '确认合成',
                    downloadBtn: '下载结果',
                    copyBtn: '复制图片',
                    resetBtn: '重置画布',
                    cancelBtn: '取消合成',
                    copied: '已复制到剪贴板！'
                }
            },
            en: {
                nav: {
                    cropStitch: 'Crop & Stitch',
                    outpainting: 'Outpainting'
                },
                theme: {
                    light: 'Light',
                    dark: 'Dark'
                },
                header: {
                    title: 'All-in-One Ratio Toolbox: Calc · Crop · Stitch · Outpaint',
                    subtitle: 'Smart ratio calculation with professional cropping, stitching, and outpainting'
                },
                imageCrop: {
                    title: 'Image Crop & Stitch',
                    uploadText: 'Click to upload, drag and drop, or paste an image here',
                    uploadHint: 'Supports JPG, PNG, GIF and more (can paste multiple)',
                    uploadBtn: 'Select Image',
                    uploadTextSmall: 'Continue adding images',
                    cropBtn: 'Crop Image',
                    rotate90Btn: 'Rotate 90°',
                    resetBtn: 'Reset Crop Area',
                    cancelBtn: 'Cancel & Re-upload',
                    originalSize: 'Original Size:',
                    cropArea: 'Crop Area:',
                    currentRatio: 'Crop Ratio:',
                    rotateLabel: 'Rotate Angle:',
                    borderRadiusLabel: 'Corner Radius:',
                    resultTitle: 'Cropped Result Preview',
                    downloadBtn: 'Download (PNG)',
                    copyBtn: 'Copy Image',
                    copiedBtn: 'Copied!',
                    newCropBtn: 'Crop New Image'
                },
                stitch: {
                    mode: 'Stitch Mode:',
                    horizontal: 'Horizontal',
                    horizontalHint: '(align by height)',
                    vertical: 'Vertical',
                    verticalHint: '(align by width)',
                    stitchBtn: 'Start Cropping',
                    clearBtn: 'Clear List',
                    placeholder: 'Paste or upload multiple images',
                    previewLabel: 'Stitch Preview',
                    dimensions: 'Total Size: ',
                    preCropBtn: 'Pre-crop Item',
                    savePreCrop: 'Apply & Back',
                    downloadBtn: 'Download Stitched',
                    copyBtn: 'Copy Stitched',
                    backToStitch: 'Back to List',
                    copied: 'Copied!',
                    preview: 'images'
                },
                config: {
                    title: 'Persistence',
                    saveBtn: 'Save Settings',
                    clearBtn: 'Clear & Reset All',
                    saveSuccess: 'Configuration saved locally!',
                    clearConfirm: 'Reset all settings and clear images? This cannot be undone.'
                },
                ratioSelect: {
                    title: 'Select Ratio',
                    vertical: 'Portrait Photo',
                    horizontal: 'Landscape Photo',
                    square: 'Square',
                    widescreen: 'Widescreen',
                    portrait: 'Portrait Screen',
                    traditional: 'Traditional',
                    verticalTraditional: 'Vertical Traditional',
                    ultrawide: 'Ultrawide',
                    tallImage: 'Tall Image',
                    ratio45: '4:5',
                    miniProgram: 'Mini Program',
                    wechatCover: 'WeChat Cover',
                    custom: 'Custom Ratio',
                    customWidth: 'Width',
                    customHeight: 'Height'
                },
                preview: {
                    title: 'Ratio Preview',
                    subtitle: 'Visual display of selected ratio',
                    resultLabel: 'Result'
                },
                calculator: {
                    title: 'Dimension Calculator',
                    currentRatio: 'Current Ratio: ',
                    inputWidth: 'Input Width',
                    inputHeight: 'Input Height',
                    calcWidth: 'Calculated Width',
                    calcHeight: 'Calculated Height',
                    widthPlaceholder: 'Enter width value',
                    heightPlaceholder: 'Enter height value',
                    clearBtn: 'Clear All Input'
                },
                instructions: {
                    title: 'Instructions:',
                    ratioCalc: 'Ratio Calculation:',
                    ratioCalcDesc: 'Select a preset ratio or input a custom ratio, then enter a value in any input field. The system will automatically calculate the other dimension.',
                    imageCrop: 'Image Cropping:',
                    imageCropDesc: 'Click to upload or drag an image to the upload area. After selecting an appropriate ratio, drag the crop box or adjust the corner handles to position the crop area. Click "Crop Image" to complete, then download the result.',
                    supported: 'Supported ratios include common photo and screen ratios. Custom ratios are also supported for calculation and cropping.'
                },
                developer: {
                    name: 'ToolBuddy',
                    title: 'Developer',
                    douyin: 'Douyin',
                    wechat: 'WeChat Official',
                    scanQR: 'Scan to Follow',
                    collapse: 'Collapse',
                    expand: 'Expand'
                },
                outpainting: {
                    sizeLabel: 'Base Size (Based on Calculator):',
                    placeholderText: 'Click to upload, paste, or drag image',
                    placeholderHint: 'Floating on green background; supports dragging, scaling & multiple layers',
                    confirmBtn: 'Confirm Composition',
                    downloadBtn: 'Download Result',
                    copyBtn: 'Copy Image',
                    resetBtn: 'Reset Canvas',
                    cancelBtn: 'Cancel Merge',
                    copied: 'Copied to clipboard!'
                }
            }
        };

        // 当前语言
        let currentLang = localStorage.getItem('language') || 'zh';

        // 更新页面文本
        function updateLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('language', lang);

            // 更新所有带有 data-i18n 属性的元素
            document.querySelectorAll('[data-i18n]').forEach(elem => {
                const keys = elem.getAttribute('data-i18n').split('.');
                let text = translations[lang];
                for (const key of keys) {
                    if (text && text[key] !== undefined) {
                        text = text[key];
                    } else {
                        text = null;
                        break;
                    }
                }
                if (text !== null) elem.textContent = text;
            });

            // 更新所有带有 data-i18n-placeholder 属性的元素
            document.querySelectorAll('[data-i18n-placeholder]').forEach(elem => {
                const keys = elem.getAttribute('data-i18n-placeholder').split('.');
                let text = translations[lang];
                for (const key of keys) {
                    if (text && text[key] !== undefined) {
                        text = text[key];
                    } else {
                        text = null;
                        break;
                    }
                }
                if (text !== null) elem.placeholder = text;
            });

            // 更新所有带有 data-i18n-title 属性的元素
            document.querySelectorAll('[data-i18n-title]').forEach(elem => {
                const keys = elem.getAttribute('data-i18n-title').split('.');
                let text = translations[lang];
                for (const key of keys) {
                    if (text && text[key] !== undefined) {
                        text = text[key];
                    } else {
                        text = null;
                        break;
                    }
                }
                if (text !== null) elem.title = text;
            });

            // 更新标题
            document.title = lang === 'zh' ?
                '比例计算器与图像裁切拼接工具 - 智能尺寸计算与图片裁切拼接' :
                'Ratio Calculator & Image Crop & Stitch Tool - Smart Calculation, Cropping & Stitching';

            // 更新 meta description
            const metaDesc = document.querySelector('meta[name="description"]');
            if (metaDesc) {
                metaDesc.content = lang === 'zh' ?
                    '专业的比例计算器和图像裁切工具,支持常用照片比例、屏幕比例等,自定义比例计算更方便,在线裁切图片' :
                    'Professional ratio calculator and image crop tool. Supports common photo and screen ratios, custom ratio calculation, and online image cropping.';
            }

            // 同步更新当前激活工具的卡片标题
            const activeTab = document.querySelector('.tool-icon-btn.active');
            if (activeTab) {
                const tool = activeTab.dataset.tool;
                const titleElem = document.querySelector('.image-crop-section .card-title');
                if (titleElem && toolLabels[tool]) {
                    titleElem.textContent = toolLabels[tool][lang];
                }
            }
        }

        // 语言切换按钮
        const langButtons = document.querySelectorAll('.lang-btn');
        langButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const lang = btn.dataset.lang;

                // 更新按钮状态
                langButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // 更新语言
                updateLanguage(lang);
            });
        });

        // 页面加载时应用保存的语言
        if (currentLang === 'en') {
            langButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === 'en');
            });
            updateLanguage('en');
        }

        // ========== 全局变量与 DOM 元素 ==========
        let currentRatio = { width: 4, height: 3 }; // 默认设为 4:3，与 UI 保持一致
        let currentUnit = 'cm'; // 默认单位为厘米
        let uploadedImage = null;
        let stitchImages = [];
        let draggedItem = null;
        let selectedImageIndex = -1;
        let preCropIndex = -1;
        let isFromStitch = false; // 追踪当前裁切图片是否来自拼接
        window.isShowingCropResult = false; // 追踪当前是否正在展示裁切结果页

        // 新增裁切高级状态
        let currentRotation = 0;
        let currentZoom = 1;
        let canvasScale = 1; // 底图显示比例
        let maxZoom = 1;
        const MIN_ZOOM = 0.1;

        // 手势追踪变量
        let isGestureActive = false;
        let initialAngle = 0;
        let initialRotation = 0;
        let initialDist = 0;
        let initialZoom = 1;

        // DOM 元素 - 核心 (裁切专项)
        const ratioButtons = document.querySelectorAll('#cropRatioGroup .ratio-btn');
        const customWidthInput = document.getElementById('customWidth');
        const customHeightInput = document.getElementById('customHeight');
        const inputWidth = document.getElementById('inputWidth');
        const inputHeight = document.getElementById('inputHeight');
        const calcHeight = document.getElementById('calcHeight');
        const calcWidth = document.getElementById('calcWidth');
        const clearBtn = document.getElementById('clearBtn');
        const previewBox = document.getElementById('previewBox');
        const previewRatio = document.getElementById('previewRatio');
        const previewDesc = document.getElementById('previewDesc');
        const currentRatioText = document.getElementById('currentRatioText');
        const resultDisplay = document.getElementById('resultDisplay');
        const resultValue = document.getElementById('resultValue');

        // DOM 元素 - 核心 (扩图专项)
        let opCurrentRatio = { width: 4, height: 3 };
        const opRatioButtons = document.querySelectorAll('#opRatioGroup .ratio-btn');
        const opCustomWidthInput = document.getElementById('opCustomWidth');
        const opCustomHeightInput = document.getElementById('opCustomHeight');
        const opInputWidth = document.getElementById('opInputWidth');
        const opInputHeight = document.getElementById('opInputHeight');
        const opCalcHeight = document.getElementById('opCalcHeight');
        const opCalcWidth = document.getElementById('opCalcWidth');
        const opClearBtn = document.getElementById('opClearBtn');
        const opPreviewBox = document.getElementById('opPreviewBox');
        const opPreviewRatio = document.getElementById('opPreviewRatio');
        const opPreviewDesc = document.getElementById('opPreviewDesc');
        const opCurrentRatioText = document.getElementById('opCurrentRatioText');
        const opResultDisplay = document.getElementById('opResultDisplay');
        const opResultValue = document.getElementById('opResultValue');
        const themeButtons = document.querySelectorAll('.theme-btn');

        // DOM 元素 - 裁切
        const imageInput = document.getElementById('imageInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const uploadPlaceholder = document.getElementById('uploadPlaceholder');
        const uploadArea = document.getElementById('uploadArea');
        const cropContainer = document.getElementById('cropContainer');
        const cropCanvas = document.getElementById('cropCanvas');
        const cropCtx = cropCanvas.getContext('2d');
        const cropBox = document.getElementById('cropBox');
        const cropOverlay = document.getElementById('cropOverlay');
        const cropBtn = document.getElementById('cropBtn');
        const resetCropBtn = document.getElementById('resetCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');
        const originalSizeElem = document.getElementById('originalSize');
        const cropSizeElem = document.getElementById('cropSize');
        const cropRatioElem = document.getElementById('cropRatio');
        const cropResult = document.getElementById('cropResult');
        const resultCanvas = document.getElementById('resultCanvas');
        const downloadBtn = document.getElementById('downloadBtn');
        const copyBtn = document.getElementById('copyBtn');
        const newCropBtn = document.getElementById('newCropBtn');
        const cropHandles = document.querySelectorAll('.crop-handle');

        // DOM 元素 - 拼接
        const stitchContainer = document.getElementById('stitchContainer');
        const stitchImageList = document.getElementById('stitchImageList');
        const stitchPreviewInfo = document.getElementById('stitchPreviewInfo');
        const stitchPreviewCanvas = document.getElementById('stitchPreviewCanvas');
        const stitchBtn = document.getElementById('stitchBtn');
        const clearStitchBtn = document.getElementById('clearStitchBtn');
        const stitchModeInputs = document.querySelectorAll('input[name="stitchMode"]');
        const uploadPlaceholderSmall = document.getElementById('uploadPlaceholderSmall');
        const uploadBtnSmall = document.getElementById('uploadBtnSmall');
        const preCropBtn = document.getElementById('preCropBtn');
        const applyPreCropBtn = document.getElementById('applyPreCropBtn');
        const savePreCropBtn = document.getElementById('savePreCropBtn');
        const downloadStitchBtn = document.getElementById('downloadStitchBtn');
        const copyStitchBtn = document.getElementById('copyStitchBtn');
        const cancelStitchBtn = document.getElementById('cancelStitchBtn');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const clearConfigBtn = document.getElementById('clearConfigBtn');

        // 裁切控制 DOM
        const rotateBtn = document.getElementById('rotateBtn');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationInput = document.getElementById('rotationInput');
        const borderRadiusSlider = document.getElementById('borderRadiusSlider');
        const borderRadiusInput = document.getElementById('borderRadiusInput');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomInput = document.getElementById('zoomInput');
        const cornerRadiusHandles = document.querySelectorAll('.corner-radius-handle');
        // const cropOverlay = document.getElementById('cropOverlay'); // Already defined
        const toast = document.getElementById('toast');

        // --- 绑定裁切控制事件 ---
        rotateBtn.addEventListener('click', () => {
            let r = currentRotation + 90;
            if (r > 180) r -= 360;
            currentRotation = r;
            rotationSlider.value = r;
            rotationInput.value = r;
            updateMaxZoom();
            drawCanvas();
        });

        rotationSlider.addEventListener('input', (e) => {
            currentRotation = parseInt(e.target.value);
            rotationInput.value = currentRotation;
            drawCanvas();
        });

        // 双击复位旋转角度
        rotationSlider.addEventListener('dblclick', () => {
            currentRotation = 0;
            rotationSlider.value = 0;
            rotationInput.value = 0;
            drawCanvas();
            showToast(currentLang === 'zh' ? '🔄 旋转角度已复位' : '🔄 Rotation reset');
        });

        rotationInput.addEventListener('input', (e) => {
            currentRotation = parseInt(e.target.value) || 0;
            rotationSlider.value = currentRotation;
            drawCanvas();
        });

        borderRadiusSlider.addEventListener('input', (e) => {
            const r = e.target.value;
            borderRadiusInput.value = r;
            cropBox.style.borderRadius = r + 'px';
        });

        // 双击复位圆角
        borderRadiusSlider.addEventListener('dblclick', () => {
            borderRadiusSlider.value = 0;
            borderRadiusInput.value = 0;
            cropBox.style.borderRadius = '0px';
            showToast(currentLang === 'zh' ? '📐 圆角已复位' : '📐 Corner radius reset');
        });

        borderRadiusInput.addEventListener('input', (e) => {
            const r = e.target.value || 0;
            borderRadiusSlider.value = r;
            cropBox.style.borderRadius = r + 'px';
        });

        zoomInBtn.addEventListener('click', () => {
            currentZoom = Math.min(maxZoom, currentZoom + 0.1);
            updateZoomUI();
        });
        zoomOutBtn.addEventListener('click', () => {
            currentZoom = Math.max(MIN_ZOOM, currentZoom - 0.1);
            updateZoomUI();
        });
        zoomInput.addEventListener('change', (e) => {
            let val = parseInt(e.target.value) / 100;
            currentZoom = Math.max(MIN_ZOOM, Math.min(maxZoom, val));
            updateZoomUI();
        });

        // 圆角控制点拖动
        let isDraggingRadius = false;
        let activeRadiusHandle = null;
        let radiusDragStart = { x: 0, y: 0 };
        let initialRadiusArr = 0;

        cornerRadiusHandles.forEach(handle => {
            const startDrag = (e) => {
                isDraggingRadius = true;
                activeRadiusHandle = handle;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                radiusDragStart = { x: clientX, y: clientY };
                initialRadiusArr = parseInt(borderRadiusSlider.value);
                e.stopPropagation();
                e.preventDefault();
            };
            handle.addEventListener('mousedown', startDrag);
            handle.addEventListener('touchstart', startDrag, { passive: false });
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingRadius) return;
            handleRadiusMove(e.clientX, e.clientY);
        });

        document.addEventListener('touchmove', (e) => {
            if (!isDraggingRadius) return;
            handleRadiusMove(e.touches[0].clientX, e.touches[0].clientY);
            e.preventDefault();
        }, { passive: false });

        function handleRadiusMove(clientX, clientY) {
            const edge = activeRadiusHandle.dataset.edge;
            const dx = clientX - radiusDragStart.x;
            const dy = clientY - radiusDragStart.y;
            let delta = 0;
            if (edge === 'top') delta = dy;
            else if (edge === 'right') delta = -dx;
            else if (edge === 'bottom') delta = -dy;
            else if (edge === 'left') delta = dx;

            let nr = Math.max(0, Math.min(250, initialRadiusArr + delta));
            nr = Math.round(nr);
            borderRadiusSlider.value = nr;
            borderRadiusInput.value = nr;
            cropBox.style.borderRadius = nr + 'px';
        }

        // 触控手势支持
        const handleGestureStart = (e) => {
            if (e.touches && e.touches.length === 2) {
                isGestureActive = true;
                isDragging = false;
                isResizing = false;
                const p1 = e.touches[0], p2 = e.touches[1];
                initialAngle = Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;
                initialRotation = currentRotation;
                initialDist = Math.hypot(p2.clientX - p1.clientX, p2.clientY - p1.clientY);
                initialZoom = currentZoom;
                e.preventDefault();
            }
        };

        const handleGestureMove = (e) => {
            if (e.touches && e.touches.length === 2 && isGestureActive) {
                const p1 = e.touches[0], p2 = e.touches[1];
                const curAngle = Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;
                let angleDiff = curAngle - initialAngle;

                // 处理角度突变
                if (angleDiff > 180) angleDiff -= 360;
                if (angleDiff < -180) angleDiff += 360;

                currentRotation = initialRotation + angleDiff;
                rotationSlider.value = Math.round(currentRotation);
                rotationInput.value = Math.round(currentRotation);

                const curDist = Math.hypot(p2.clientX - p1.clientX, p2.clientY - p1.clientY);
                if (initialDist > 0) {
                    // 增加阻尼系数，降低灵敏度 (0.6)
                    const rawScale = curDist / initialDist;
                    const dampedScale = 1 + (rawScale - 1) * 0.6;
                    currentZoom = Math.max(MIN_ZOOM, Math.min(maxZoom, initialZoom * dampedScale));
                    updateZoomUI();
                }
                drawCanvas();
                e.preventDefault();
            }
        };

        cropOverlay.addEventListener('touchstart', handleGestureStart, { passive: false });
        cropOverlay.addEventListener('touchmove', handleGestureMove, { passive: false });
        cropBox.addEventListener('touchstart', handleGestureStart, { passive: false });
        cropBox.addEventListener('touchmove', handleGestureMove, { passive: false });

        // Mac Trackpad / Wheel Support
        const handleWheel = (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                // 动态阻尼算法：基于 deltaY 的微量计算
                const zoomSensitivity = 0.005; // 极低灵敏度
                // 限制变化幅度，防止甚至在极快滑动时失控
                const delta = Math.max(-0.2, Math.min(0.2, e.deltaY * zoomSensitivity));

                // 使用 1 - delta 来平滑过渡
                currentZoom = Math.max(MIN_ZOOM, Math.min(maxZoom, currentZoom * (1 - delta)));
                updateZoomUI();
            }
        };
        cropOverlay.addEventListener('wheel', handleWheel, { passive: false });
        cropBox.addEventListener('wheel', handleWheel, { passive: false });

        const handleMacGestureStart = (e) => {
            isGestureActive = true;
            initialRotation = currentRotation;
            initialZoom = currentZoom;
            if (e.cancelable) e.preventDefault();
        };
        const handleMacGestureChange = (e) => {
            if (!isGestureActive) return;
            currentRotation = initialRotation + e.rotation;
            rotationSlider.value = Math.round(currentRotation);
            rotationInput.value = Math.round(currentRotation);

            // 深度阻尼 (0.3)，适合高灵敏度触控板
            const dampedScale = 1 + (e.scale - 1) * 0.3;
            currentZoom = Math.max(MIN_ZOOM, Math.min(maxZoom, initialZoom * dampedScale));

            updateZoomUI();
            drawCanvas();
            if (e.cancelable) e.preventDefault();
        };
        const handleMacGestureEnd = () => {
            isGestureActive = false;
        };

        cropOverlay.addEventListener('gesturestart', handleMacGestureStart);
        cropOverlay.addEventListener('gesturechange', handleMacGestureChange);
        cropOverlay.addEventListener('gestureend', handleMacGestureEnd);
        cropBox.addEventListener('gesturestart', handleMacGestureStart);
        cropBox.addEventListener('gesturechange', handleMacGestureChange);
        cropBox.addEventListener('gestureend', handleMacGestureEnd);

        // --- 控制逻辑结束 ---

        // 主题切换
        themeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const theme = btn.dataset.theme;

                // 更新按钮状态
                themeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // 应用主题
                if (theme === 'dark') {
                    document.body.classList.add('dark-theme');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.body.classList.remove('dark-theme');
                    localStorage.setItem('theme', 'light');
                }
            });
        });

        // 加载保存的主题
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-theme');
            themeButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.theme === 'dark');
            });
        }

        // ========== 裁切工具比例逻辑 ==========
        function updateRatio(width, height) {
            currentRatio = { width, height };
            currentRatioText.textContent = `${width}:${height}`;
            previewRatio.textContent = `${width}:${height}`;
            previewDesc.textContent = `${width} × ${height}`;

            updatePreviewBox();
            recalculate();
        }

        function updatePreviewBox() {
            const maxWidth = 320;
            const maxHeight = 280;
            const ratio = currentRatio.width / currentRatio.height;
            let width, height;
            if (ratio > maxWidth / maxHeight) {
                width = maxWidth;
                height = maxWidth / ratio;
            } else {
                height = maxHeight;
                width = maxHeight * ratio;
            }
            previewBox.style.width = `${width}px`;
            previewBox.style.height = `${height}px`;
        }

        ratioButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                ratioButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                customWidthInput.value = '';
                customHeightInput.value = '';
                const [width, height] = btn.dataset.ratio.split(':').map(Number);
                updateRatio(width, height);
            });
        });

        [customWidthInput, customHeightInput].forEach(input => {
            input.addEventListener('input', () => {
                const w = parseFloat(customWidthInput.value);
                const h = parseFloat(customHeightInput.value);
                if (w > 0 && h > 0) {
                    ratioButtons.forEach(btn => btn.classList.remove('active'));
                    updateRatio(w, h);
                }
            });
        });

        function recalculate() {
            const w = parseFloat(inputWidth.value);
            const h = parseFloat(inputHeight.value);
            const ratio = currentRatio.width / currentRatio.height;
            if (document.activeElement === inputWidth) {
                if (w > 0) {
                    const resH = w / ratio;
                    calcHeight.value = resH.toFixed(2);
                    resultValue.textContent = `${w} × ${resH.toFixed(2)}`;
                    resultDisplay.style.display = 'block';
                } else {
                    calcHeight.value = '';
                    resultDisplay.style.display = 'none';
                }
            } else if (document.activeElement === inputHeight) {
                if (h > 0) {
                    const resW = h * ratio;
                    calcWidth.value = resW.toFixed(2);
                    resultValue.textContent = `${resW.toFixed(2)} × ${h}`;
                    resultDisplay.style.display = 'block';
                } else {
                    calcWidth.value = '';
                    resultDisplay.style.display = 'none';
                }
            }
        }
        inputWidth.addEventListener('input', recalculate);
        inputHeight.addEventListener('input', recalculate);
        clearBtn.addEventListener('click', () => {
            inputWidth.value = '';
            inputHeight.value = '';
            calcWidth.value = '';
            calcHeight.value = '';
            resultDisplay.style.display = 'none';
        });

        // ========== 扩图底板专用比例逻辑 ==========
        function opUpdateRatio(width, height) {
            opCurrentRatio = { width, height };
            opCurrentRatioText.textContent = `${width}:${height}`;
            opPreviewRatio.textContent = `${width}:${height}`;
            opPreviewDesc.textContent = `${width} × ${height}`;

            opUpdatePreviewBox();
            opRecalculate();

            // 实时同步底板基础尺寸
            if (typeof initOutpaintingBase === 'function') initOutpaintingBase();
        }

        function opUpdatePreviewBox() {
            const maxWidth = 320;
            const maxHeight = 280;
            const ratio = opCurrentRatio.width / opCurrentRatio.height;
            let width, height;
            if (ratio > maxWidth / maxHeight) {
                width = maxWidth;
                height = maxWidth / ratio;
            } else {
                height = maxHeight;
                width = maxHeight * ratio;
            }
            opPreviewBox.style.width = `${width}px`;
            opPreviewBox.style.height = `${height}px`;
        }

        opRatioButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                opRatioButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                opCustomWidthInput.value = '';
                opCustomHeightInput.value = '';
                const [width, height] = btn.dataset.ratio.split(':').map(Number);
                opUpdateRatio(width, height);
            });
        });

        [opCustomWidthInput, opCustomHeightInput].forEach(input => {
            input.addEventListener('input', () => {
                const w = parseFloat(opCustomWidthInput.value);
                const h = parseFloat(opCustomHeightInput.value);
                if (w > 0 && h > 0) {
                    opRatioButtons.forEach(btn => btn.classList.remove('active'));
                    opUpdateRatio(w, h);
                }
            });
        });

        function opRecalculate() {
            const w = parseFloat(opInputWidth.value);
            const h = parseFloat(opInputHeight.value);
            const ratio = opCurrentRatio.width / opCurrentRatio.height;
            if (document.activeElement === opInputWidth) {
                if (w > 0) {
                    const resH = w / ratio;
                    opCalcHeight.value = resH.toFixed(2);
                    opResultValue.textContent = `${w} × ${resH.toFixed(2)}`;
                    opResultDisplay.style.display = 'block';
                } else {
                    opCalcHeight.value = '';
                    opResultDisplay.style.display = 'none';
                }
            } else if (document.activeElement === opInputHeight) {
                if (h > 0) {
                    const resW = h * ratio;
                    opCalcWidth.value = resW.toFixed(2);
                    opResultValue.textContent = `${resW.toFixed(2)} × ${h}`;
                    opResultDisplay.style.display = 'block';
                } else {
                    opCalcWidth.value = '';
                    opResultDisplay.style.display = 'none';
                }
            }
        }
        opInputWidth.addEventListener('input', opRecalculate);
        opInputHeight.addEventListener('input', opRecalculate);
        opClearBtn.addEventListener('click', () => {
            opInputWidth.value = '';
            opInputHeight.value = '';
            opCalcWidth.value = '';
            opCalcHeight.value = '';
            opResultDisplay.style.display = 'none';
        });

        // 初始化
        updatePreviewBox();
        opUpdatePreviewBox();

        // ========== 图像裁切与监听器 ==========
        let cropData = {
            x: 50,
            y: 50,
            width: 300,
            height: 400
        };
        let isDragging = false;
        let isResizing = false;
        let dragStart = { x: 0, y: 0 };
        let currentHandle = null;
        // let canvasScale = 1; // Already defined

        // 上传按钮点击
        uploadBtn.addEventListener('click', () => {
            imageInput.click();
        });

        // 小上传按钮点击
        uploadBtnSmall.addEventListener('click', () => {
            imageInput.click();
        });

        // 小上传区域点击
        uploadPlaceholderSmall.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                imageInput.click();
            }
        });

        // 上传区域点击
        uploadPlaceholder.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                imageInput.click();
            }
        });

        // 拖拽上传
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadPlaceholder.style.borderColor = 'var(--border-glow)';
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadPlaceholder.style.borderColor = 'var(--border-color)';
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadPlaceholder.style.borderColor = 'var(--border-color)';
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length === 0) return;

            handleMultipleFiles(files);
        });

        uploadPlaceholderSmall.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            uploadPlaceholderSmall.style.borderColor = 'var(--border-color)';
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length === 0) return;

            handleMultipleFiles(files);
        });

        // 统一处理多文件或单文件进入逻辑
        function handleMultipleFiles(files) {
            if (files.length === 0) return;

            // 如果当前已经是裁切状态且拖入新图，应当提示或切换回拼接
            const totalTargetCount = stitchImages.length + files.length;
            let loadedCount = 0;

            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        stitchImages.push({
                            file: file,
                            src: e.target.result,
                            width: img.width,
                            height: img.height
                        });
                        loadedCount++;

                        // 等待这一批所有图片都加载完
                        if (loadedCount === files.length) {
                            if (totalTargetCount === 1) {
                                // 只有一张图的情况：直接进裁切
                                performStitch();
                            } else {
                                // 多张图：确保进入拼接界面
                                showStitchUI();
                                renderStitchImageList();
                                updateStitchPreview();
                            }
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // 防止拖拽图片到页面其他地方打开新页面
        document.addEventListener('dragover', (e) => {
            const hasImageFiles = Array.from(e.dataTransfer?.files || []).some(f => f.type.startsWith('image/'));
            if (hasImageFiles) {
                e.preventDefault();
            }
        });

        document.addEventListener('drop', (e) => {
            // 如果已经在特定区域处理了，就不再处理
            if (e.defaultPrevented) return;

            // 只有在“图像裁切与拼接工具”激活时才处理
            const isImageToolActive = document.querySelector('[data-tool="image-tool"]').classList.contains('active');
            if (!isImageToolActive) return;

            const hasImageFiles = Array.from(e.dataTransfer?.files || []).some(f => f.type.startsWith('image/'));
            if (hasImageFiles) {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                handleMultipleFiles(files);
            }
        });

        // 文件选择 - 支持多选
        imageInput.addEventListener('change', (e) => {
            // 只有在“图像裁切与拼接工具”激活时才处理
            const isImageToolActive = document.querySelector('[data-tool="image-tool"]').classList.contains('active');
            if (!isImageToolActive) return;

            const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
            if (files.length === 0) return;

            handleMultipleFiles(files);
            imageInput.value = '';
        });

        // 剪切板粘贴图片 - 支持多张图片
        document.addEventListener('paste', (e) => {
            // 只有在“图像裁切与拼接工具”激活时才处理
            const isImageToolActive = document.querySelector('[data-tool="image-tool"]').classList.contains('active');
            if (!isImageToolActive) return;

            // 如果是输入预览相关的粘贴，不在此处处理
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            const items = e.clipboardData?.items;
            if (!items) return;

            const imageFiles = [];
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.indexOf('image') !== -1) {
                    const file = item.getAsFile();
                    if (file) {
                        imageFiles.push(file);
                    }
                }
            }

            if (imageFiles.length === 0) return;

            e.preventDefault();

            // 如果粘贴了图片，总是添加到拼接列表
            imageFiles.forEach(file => addImageToStitch(file));
        });

        // ========== 图片拼接功能逻辑 ==========

        function showStitchUI() {
            uploadPlaceholder.style.display = 'none';
            cropContainer.style.display = 'none';
            cropResult.style.display = 'none';
            stitchContainer.style.display = 'block';
            renderStitchImageList();
            updateStitchPreview();

            // 核心功能逻辑优化：如果是第一张图，自动进入裁切
            if (stitchImages.length === 1 && !isFromStitch) {
                selectStitchImage(0);
                startPreCrop();
            }
        }

        function hideStitchUI() {
            stitchContainer.style.display = 'none';
            uploadPlaceholder.style.display = 'block';
            selectedImageIndex = -1;
        }

        function addImageToStitch(file) {
            // 这个函数现在主要用于逐个单点添加图片的逻辑
            handleMultipleFiles([file]);
        }

        function renderStitchImageList() {
            if (stitchImages.length === 0) {
                stitchImageList.innerHTML = `
                    <div class="stitch-placeholder">
                        <div class="stitch-placeholder-icon">📋</div>
                        <div data-i18n="stitch.placeholder">粘贴或上传多张图片</div>
                    </div>
                `;
                updateLanguage(currentLang);
                return;
            }

            const mode = document.querySelector('input[name="stitchMode"]:checked').value;
            let html = '';

            stitchImages.forEach((imgData, index) => {
                const arrow = index < stitchImages.length - 1 ?
                    `<div class="stitch-arrow">${mode === 'horizontal' ? '⬌' : '⬍'}</div>` : '';
                const isSelected = selectedImageIndex === index;

                html += `
                    <div class="stitch-image-item ${isSelected ? 'selected' : ''}" draggable="true" data-index="${index}" onclick="selectStitchImage(${index})">
                        <div class="stitch-image-order">${index + 1}</div>
                        <img src="${imgData.src}" class="stitch-image-thumb" alt="Image ${index + 1}">
                        <div class="stitch-image-info">${imgData.width} × ${imgData.height}</div>
                        <button class="stitch-image-remove" onclick="event.stopPropagation(); removeStitchImage(${index})">×</button>
                        ${arrow}
                    </div>
                `;
            });

            stitchImageList.innerHTML = html;

            document.querySelectorAll('.stitch-image-item').forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        function selectStitchImage(index) {
            if (selectedImageIndex === index) {
                selectedImageIndex = -1;
            } else {
                selectedImageIndex = index;
            }
            renderStitchImageList();
            updateStitchPreview();
        }

        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            if (draggedItem !== this) {
                const fromIndex = parseInt(draggedItem.dataset.index);
                const toIndex = parseInt(this.dataset.index);

                const [removed] = stitchImages.splice(fromIndex, 1);
                stitchImages.splice(toIndex, 0, removed);

                renderStitchImageList();
                updateStitchPreview();
            }
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
            draggedItem = null;
        }

        function removeStitchImage(index) {
            stitchImages.splice(index, 1);
            if (selectedImageIndex === index) {
                selectedImageIndex = -1;
            } else if (selectedImageIndex > index) {
                selectedImageIndex--;
            }
            if (stitchImages.length === 0) {
                hideStitchUI();
            } else {
                renderStitchImageList();
                updateStitchPreview();
            }
        }

        function clearStitchImages() {
            stitchImages = [];
            selectedImageIndex = -1;
            hideStitchUI();
            imageInput.value = '';
        }

        function updateStitchPreview() {
            const ctx = stitchPreviewCanvas.getContext('2d');

            if (stitchImages.length === 0) {
                stitchPreviewCanvas.width = 0;
                stitchPreviewCanvas.height = 0;
                stitchPreviewInfo.innerHTML = '';
                return;
            }

            const mode = document.querySelector('input[name="stitchMode"]:checked').value;

            if (selectedImageIndex >= 0 && selectedImageIndex < stitchImages.length) {
                const imgData = stitchImages[selectedImageIndex];
                stitchPreviewCanvas.width = imgData.width;
                stitchPreviewCanvas.height = imgData.height;
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, stitchPreviewCanvas.width, stitchPreviewCanvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = imgData.src;
                stitchPreviewInfo.innerHTML = `
                    <div class="stitch-preview-text">
                        ${currentLang === 'zh' ? '单张预览' : 'Single Image Preview'}: ${imgData.width} × ${imgData.height}
                    </div>
                `;
                // 显示预裁切按钮
                preCropBtn.style.display = 'flex';
                // 隐藏普通拼接按钮（如果要先预裁切）
                stitchBtn.style.display = 'none';
                downloadStitchBtn.style.display = 'none'; // 隐藏下载拼接图按钮
                copyStitchBtn.style.display = 'none'; // 隐藏复制拼接图按钮
                return;
            } else {
                preCropBtn.style.display = 'none';
                stitchBtn.style.display = 'flex';
                if (stitchImages.length >= 2) {
                    downloadStitchBtn.style.display = 'flex';
                    copyStitchBtn.style.display = 'flex';
                } else {
                    downloadStitchBtn.style.display = 'none';
                    copyStitchBtn.style.display = 'none';
                }
            }

            if (stitchImages.length === 1) {
                const imgData = stitchImages[0];
                stitchPreviewCanvas.width = imgData.width;
                stitchPreviewCanvas.height = imgData.height;
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, stitchPreviewCanvas.width, stitchPreviewCanvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = imgData.src;
                stitchPreviewInfo.innerHTML = `
                    <div class="stitch-preview-text">
                        ${currentLang === 'zh' ? '已添加1张图片，点击“开始裁切”或继续添加' : '1 image added. Click "Start Crop" or add more.'}
                    </div>
                `;
                // 更新按钮文本
                const stitchBtnText = stitchBtn.querySelector('span:last-child');
                if (stitchBtnText) {
                    stitchBtnText.textContent = translations[currentLang].imageCrop.cropBtn.replace('✂️ ', '');
                    const iconSpan = stitchBtn.querySelector('span:first-child');
                    if (iconSpan) iconSpan.textContent = '✂️ ';
                }
                downloadStitchBtn.style.display = 'none'; // 单张图片不显示下载拼接图按钮
                copyStitchBtn.style.display = 'none';
                return;
            } else {
                // 恢复拼接按钮文本
                const stitchBtnText = stitchBtn.querySelector('span:last-child');
                if (stitchBtnText) {
                    stitchBtnText.textContent = translations[currentLang].stitch.stitchBtn.replace('🔗 ', '').replace('拼接图片', '拼接图片'); // 确保兼容
                    const iconSpan = stitchBtn.querySelector('span:first-child');
                    if (iconSpan) {
                        // 恢复图标 (如果没有 SVG 则放入 emoji，建议在 HTML 初始化时就带 SVG)
                        if (!iconSpan.querySelector('svg')) {
                            iconSpan.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>';
                        }
                    }
                }
                // 仅在非选中单图状态下显示
                if (selectedImageIndex === -1) {
                    downloadStitchBtn.style.display = 'flex';
                    copyStitchBtn.style.display = 'flex';
                }
            }

            let totalWidth = 0, totalHeight = 0;

            if (mode === 'horizontal') {
                const maxHeight = Math.max(...stitchImages.map(img => img.height));
                totalHeight = maxHeight;
                stitchImages.forEach(img => {
                    const scale = maxHeight / img.height;
                    totalWidth += img.width * scale;
                });
            } else {
                const maxWidth = Math.max(...stitchImages.map(img => img.width));
                totalWidth = maxWidth;
                stitchImages.forEach(img => {
                    const scale = maxWidth / img.width;
                    totalHeight += img.height * scale;
                });
            }

            stitchPreviewCanvas.width = totalWidth;
            stitchPreviewCanvas.height = totalHeight;

            const i18n = translations[currentLang];
            stitchPreviewInfo.innerHTML = `
                <div class="stitch-preview-text">
                    ${i18n.stitch.dimensions}<span>${Math.round(totalWidth)} × ${Math.round(totalHeight)}</span>
                    (${stitchImages.length} ${i18n.stitch.preview})
                </div>
            `;

            Promise.all(stitchImages.map(imgData => loadImageFromSrc(imgData.src))).then(images => {
                ctx.clearRect(0, 0, totalWidth, totalHeight);

                if (mode === 'horizontal') {
                    const maxHeight = Math.max(...stitchImages.map(img => img.height));
                    let x = 0;
                    images.forEach((img, index) => {
                        const scale = maxHeight / stitchImages[index].height;
                        const scaledWidth = stitchImages[index].width * scale;
                        ctx.drawImage(img, x, 0, scaledWidth, maxHeight);
                        x += scaledWidth;
                    });
                } else {
                    const maxWidth = Math.max(...stitchImages.map(img => img.width));
                    let y = 0;
                    images.forEach((img, index) => {
                        const scale = maxWidth / stitchImages[index].width;
                        const scaledHeight = stitchImages[index].height * scale;
                        ctx.drawImage(img, 0, y, maxWidth, scaledHeight);
                        y += scaledHeight;
                    });
                }
            });
        }

        async function performStitch() {
            if (stitchImages.length === 0) return;

            if (stitchImages.length === 1) {
                const img = await loadImageFromSrc(stitchImages[0].src);
                uploadedImage = img;
                isFromStitch = false;
                cancelStitchBtn.style.display = 'none';
                stitchImages = [];
                window.isShowingCropResult = false;
                hideStitchUI();
                initCropArea();
                uploadPlaceholder.style.display = 'none';
                cropContainer.style.display = 'block';
                return;
            }

            isFromStitch = true;
            cancelStitchBtn.style.display = 'flex';


            const mode = document.querySelector('input[name="stitchMode"]:checked').value;

            if (mode === 'horizontal') {
                const maxHeight = Math.max(...stitchImages.map(img => img.height));
                const totalWidth = stitchImages.reduce((sum, img) => {
                    const scale = maxHeight / img.height;
                    return sum + img.width * scale;
                }, 0);

                const canvas = document.createElement('canvas');
                canvas.width = totalWidth;
                canvas.height = maxHeight;
                const ctx = canvas.getContext('2d');

                let x = 0;
                for (const imgData of stitchImages) {
                    const img = await loadImageFromSrc(imgData.src);
                    const scale = maxHeight / imgData.height;
                    const scaledWidth = imgData.width * scale;
                    ctx.drawImage(img, x, 0, scaledWidth, maxHeight);
                    x += scaledWidth;
                }

                const stitchedImg = new Image();
                stitchedImg.onload = () => {
                    uploadedImage = stitchedImg;
                    // 不再清除 stitchImages，以便撤回
                    // 确保隐藏拼接 UI (虽然之前可能漏了，这里补上更稳健)
                    if (typeof hideStitchUI === 'function') hideStitchUI();
                    else stitchContainer.style.display = 'none';

                    initCropArea();
                    uploadPlaceholder.style.display = 'none';
                    cropContainer.style.display = 'block';
                    cropResult.style.display = 'none';
                    window.isShowingCropResult = false;

                    // 自动滚动到裁切框
                    setTimeout(() => {
                        const target = document.getElementById('cropContainer');
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 100);
                };
                stitchedImg.src = canvas.toDataURL('image/png');
            } else {
                const maxWidth = Math.max(...stitchImages.map(img => img.width));
                const totalHeight = stitchImages.reduce((sum, img) => {
                    const scale = maxWidth / img.width;
                    return sum + img.height * scale;
                }, 0);

                const canvas = document.createElement('canvas');
                canvas.width = maxWidth;
                canvas.height = totalHeight;
                const ctx = canvas.getContext('2d');

                let y = 0;
                for (const imgData of stitchImages) {
                    const img = await loadImageFromSrc(imgData.src);
                    const scale = maxWidth / imgData.width;
                    const scaledHeight = imgData.height * scale;
                    ctx.drawImage(img, 0, y, maxWidth, scaledHeight);
                    y += scaledHeight;
                }

                const stitchedImg = new Image();
                stitchedImg.onload = () => {
                    uploadedImage = stitchedImg;
                    // 不再清除 stitchImages，以便撤回
                    hideStitchUI();
                    initCropArea();
                    uploadPlaceholder.style.display = 'none';
                    cropContainer.style.display = 'block';
                    cropResult.style.display = 'none';
                    window.isShowingCropResult = false;

                    // 自动滚动到裁切框
                    setTimeout(() => {
                        const target = document.getElementById('cropContainer');
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 100);
                };
                stitchedImg.src = canvas.toDataURL('image/png');
            }
        }

        function loadImageFromSrc(src) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.src = src;
            });
        }

        stitchModeInputs.forEach(input => {
            input.addEventListener('change', () => {
                renderStitchImageList();
                updateStitchPreview();
            });
        });

        stitchBtn.addEventListener('click', performStitch);
        clearStitchBtn.addEventListener('click', clearStitchImages);

        window.removeStitchImage = removeStitchImage;
        window.selectStitchImage = selectStitchImage;

        // 执行预裁切前的初始化
        async function startPreCrop() {
            if (selectedImageIndex < 0) return;

            preCropIndex = selectedImageIndex;
            const imgData = stitchImages[preCropIndex];

            uploadedImage = await loadImageFromSrc(imgData.src);

            stitchContainer.style.display = 'none';
            cropContainer.style.display = 'block';
            cropResult.style.display = 'none';
            window.isShowingCropResult = false;
            savePreCropBtn.style.display = 'none'; // 还没裁，先隐藏

            initCropArea();

            // 平滑滑动到裁切区域顶部
            setTimeout(() => {
                const target = document.querySelector('.image-crop-section');
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 100);
        }


        // 撤回拼接并返回列表
        function cancelStitch() {
            isFromStitch = false;
            cancelStitchBtn.style.display = 'none';
            showStitchUI();

            // 确保列表和预览状态正确
            renderStitchImageList();
            updateStitchPreview();

            // 平滑回滚到预览区
            setTimeout(() => {
                const target = document.querySelector('.stitch-preview-container');
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 100);
        }

        preCropBtn.addEventListener('click', startPreCrop);
        cancelStitchBtn.addEventListener('click', () => {
            preCropIndex = -1;
            cancelStitch();
        });

        // 生成拼接画布
        async function createStitchCanvas() {
            if (stitchImages.length < 2) return null;

            const mode = document.querySelector('input[name="stitchMode"]:checked').value;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            if (mode === 'horizontal') {
                const maxHeight = Math.max(...stitchImages.map(img => img.height));
                const totalWidth = stitchImages.reduce((sum, img) => {
                    const scale = maxHeight / img.height;
                    return sum + img.width * scale;
                }, 0);
                canvas.width = totalWidth;
                canvas.height = maxHeight;
                let x = 0;
                for (const imgData of stitchImages) {
                    const img = await loadImageFromSrc(imgData.src);
                    const scale = maxHeight / imgData.height;
                    const scaledWidth = imgData.width * scale;
                    ctx.drawImage(img, x, 0, scaledWidth, maxHeight);
                    x += scaledWidth;
                }
            } else {
                const maxWidth = Math.max(...stitchImages.map(img => img.width));
                const totalHeight = stitchImages.reduce((sum, img) => {
                    const scale = maxWidth / img.width;
                    return sum + img.height * scale;
                }, 0);
                canvas.width = maxWidth;
                canvas.height = totalHeight;
                let y = 0;
                for (const imgData of stitchImages) {
                    const img = await loadImageFromSrc(imgData.src);
                    const scale = maxWidth / imgData.width;
                    const scaledHeight = imgData.height * scale;
                    ctx.drawImage(img, 0, y, maxWidth, scaledHeight);
                    y += scaledHeight;
                }
            }
            return canvas;
        }

        // 直接下载
        async function downloadStitchResult() {
            const canvas = await createStitchCanvas();
            if (!canvas) return;

            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `stitched_image_${new Date().getTime()}.png`;
                link.href = url;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(url), 100);
            }, 'image/png');
        }

        // 通用复制图片到剪贴板函数（兼容 Safari 和 Chrome）
        // 通用复制图片到剪贴板函数（兼容 Safari 和 Chrome）
        async function copyImageToClipboard(imageSource, successCallback, failCallback) {
            try {
                // 检查剪贴板 API 是否可用
                if (!navigator.clipboard || typeof ClipboardItem === 'undefined') {
                    throw new Error('Clipboard API not supported');
                }

                // 构造一个 Promise，该 Promise 最终会 Resolve 为一个 Blob
                // 这允许我们在数据准备好之前就调用 clipboard.write，从而满足 Safari 的同步调用要求
                const blobPromise = new Promise(async (resolve, reject) => {
                    try {
                        let canvas = imageSource;
                        // 如果传入的是 Promise（例如来自 createStitchCanvas()），先等待其解析
                        if (imageSource instanceof Promise) {
                            canvas = await imageSource;
                        }

                        if (!canvas) {
                            reject(new Error('Canvas generation failed'));
                            return;
                        }

                        canvas.toBlob((blob) => {
                            if (blob) resolve(blob);
                            else reject(new Error('Failed to create blob'));
                        }, 'image/png');
                    } catch (err) {
                        reject(err);
                    }
                });

                // 关键点：这里必须同步创建 ClipboardItem 并立即调用 write
                // 将 Blob 的 Promise 传递给 ClipboardItem
                const item = new ClipboardItem({ 'image/png': blobPromise });
                await navigator.clipboard.write([item]);

                if (successCallback) successCallback();
                return true;
            } catch (err) {
                console.error('Copy failed:', err);
                if (failCallback) failCallback(err);
                return false;
            }
        }

        // 直接复制
        function copyStitchResult() {
            // 1. 同步检查是否有足够的图片（不能使用 await，否则会断开 User Gesture）
            if (!stitchImages || stitchImages.length < 2) {
                showToast(currentLang === 'zh' ? '⚠️ 至少需要2张图片才能拼接' : '⚠️ Need at least 2 images');
                return;
            }

            // 2. 立即启动 Canvas 生成任务，拿到 Promise
            const canvasPromise = createStitchCanvas();

            // 3. 获取原始按钮文本用于后续恢复
            const originalText = copyStitchBtn.querySelector('span:last-child').textContent;

            // 4. 将 Promise 传递给复制函数，这样 clipboard.write 可以立即被同步调用
            copyImageToClipboard(
                canvasPromise,
                () => {
                    // 成功反馈
                    copyStitchBtn.querySelector('span:last-child').textContent = translations[currentLang].stitch.copied;
                    copyStitchBtn.classList.remove('crop-btn-primary');
                    copyStitchBtn.classList.add('crop-btn-success');
                    showToast(currentLang === 'zh' ? '✅ 已复制到剪贴板' : '✅ Copied to clipboard');

                    setTimeout(() => {
                        copyStitchBtn.querySelector('span:last-child').textContent = originalText;
                        copyStitchBtn.classList.add('crop-btn-primary');
                        copyStitchBtn.classList.remove('crop-btn-success');
                    }, 2000);
                },
                (err) => {
                    console.log('Copy error caught:', err); // Debug
                    // 复制失败处理逻辑 Fallback
                    // 虽然我们尽力适配了 Safari，但如果还是失败（比如iOS版本极老），走自动下载
                    const link = document.createElement('a');
                    link.download = `stitch-result-${new Date().getTime()}.png`;

                    // 注意：这里需要再次等待 promise 才能拿到 URL，因为 copy 失败了
                    canvasPromise.then(canvas => {
                        if (canvas) {
                            link.href = canvas.toDataURL('image/png');
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            showToast(currentLang === 'zh' ? '⚠️ 浏览器限制无法直接复制，已自动为您下载' : '⚠️ Copied failed, downloading instead');
                        }
                    }).catch(e => {
                        showToast(currentLang === 'zh' ? '❌ 复制失败，请尝试手动下载' : '❌ Copy failed, please download manually');
                    });
                }
            );
        }

        downloadStitchBtn.addEventListener('click', downloadStitchResult);
        copyStitchBtn.addEventListener('click', copyStitchResult);

        // ========== 持久化存储 (IndexedDB) ==========
        const DB_NAME = 'ImageCropToolDB';
        const STORE_NAME = 'appConfig';

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e.target.error);
            });
        }

        async function saveToDB(key, data) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.put(data, key);
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            });
        }

        async function getFromDB(key) {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function clearDB() {
            const db = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.clear();
                transaction.oncomplete = () => resolve();
            });
        }

        // 保存配置
        async function saveConfig() {
            const config = {
                currentRatio,
                inputWidth: inputWidth.value,
                inputHeight: inputHeight.value,
                calcWidth: calcWidth.value,
                calcHeight: calcHeight.value,
                customWidth: customWidthInput.value,
                customHeight: customHeightInput.value,
                stitchMode: document.querySelector('input[name="stitchMode"]:checked').value,
                stitchImages: stitchImages // 包含图片数据
            };

            await saveToDB('userConfig', config);
            alert(translations[currentLang].config.saveSuccess);
        }

        // 加载配置
        async function loadConfig() {
            const config = await getFromDB('userConfig');
            if (!config) return;

            // 恢复属性
            if (config.currentRatio) {
                currentRatio = config.currentRatio;
                // 找到对应的比例按钮并激活，或者设置自定义比例
                let foundRatio = false;
                ratioButtons.forEach(btn => {
                    const [w, h] = btn.dataset.ratio.split(':').map(Number);
                    if (w === currentRatio.width && h === currentRatio.height) {
                        btn.classList.add('active');
                        foundRatio = true;
                    } else {
                        btn.classList.remove('active');
                    }
                });
                if (!foundRatio) {
                    customWidthInput.value = currentRatio.width;
                    customHeightInput.value = currentRatio.height;
                }
                updateRatio(currentRatio.width, currentRatio.height);
                // 同步更新扩图按钮状态
                if (typeof opRatioButtons !== 'undefined') {
                    opRatioButtons.forEach(btn => {
                        const [w, h] = btn.dataset.ratio.split(':').map(Number);
                        if (w === currentRatio.width && h === currentRatio.height) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                }
            }

            inputWidth.value = config.inputWidth || '';
            inputHeight.value = config.inputHeight || '';
            calcWidth.value = config.calcWidth || '';
            calcHeight.value = config.calcHeight || '';
            customWidthInput.value = config.customWidth || '';
            customHeightInput.value = config.customHeight || '';

            if (config.stitchMode) {
                const stitchModeRadio = document.querySelector(`input[name="stitchMode"][value="${config.stitchMode}"]`);
                if (stitchModeRadio) {
                    stitchModeRadio.checked = true;
                }
            }

            if (config.stitchImages && config.stitchImages.length > 0) {
                stitchImages = config.stitchImages;
                showStitchUI();
                renderStitchImageList();
                updateStitchPreview();
            }

            recalculate();
        }

        // 清除配置
        async function clearConfig() {
            if (!confirm(translations[currentLang].config.clearConfirm)) return;

            await clearDB();
            localStorage.removeItem('theme');
            localStorage.removeItem('language'); // 也清除语言设置
            location.reload(); // 刷新以恢复原始状态
        }

        saveConfigBtn.addEventListener('click', saveConfig);
        clearConfigBtn.addEventListener('click', clearConfig);

        // 页面加完毕后加载配置
        window.addEventListener('load', loadConfig);
        // ========== 原有图片加载功能 ==========
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    isFromStitch = false; // 普通上传，关闭标志
                    cancelStitchBtn.style.display = 'none';

                    // 先显示容器，确保能获取到正确的各种尺寸
                    uploadPlaceholder.style.display = 'none';
                    cropContainer.style.display = 'block';
                    cropResult.style.display = 'none';

                    // 稍微延迟以确保DOM布局更新完成，解决移动端裁切框过大问题
                    setTimeout(() => {
                        initCropArea();
                    }, 10);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 初始化裁切区域
        function initCropArea() {
            currentRotation = 0;
            borderRadiusSlider.value = 0;
            borderRadiusInput.value = 0;
            rotationSlider.value = 0;
            rotationInput.value = 0;
            cropBox.style.borderRadius = '0px';

            // 先计算最大缩放限制
            updateMaxZoom();

            // 初始缩放不应超过最大限制 (防止大图加载时初始溢出)
            currentZoom = Math.min(1.0, maxZoom);
            zoomInput.value = Math.round(currentZoom * 100);

            drawCanvas();
            resetCropArea();
            updateZoomUI();

            // 更新信息
            originalSizeElem.textContent = `${uploadedImage.width} × ${uploadedImage.height}`;
            updateCropInfo();
        }

        // 绘制底图（支持旋转与缩放）
        function drawCanvas() {
            const wrapper = document.querySelector('.crop-canvas-wrapper');
            // 获取容器宽度（不含 padding，因为 wrapper 已经处理了负 margin 撑满卡片）
            // 这里直接用 clientWidth 即可，它现在代表满宽
            const maxWidth = wrapper.clientWidth || 800;
            // 彻底移除高度限制，允许长图纵向延伸

            // Calculate rotated bounding box dimensions
            const rad = currentRotation * Math.PI / 180;
            const absCos = Math.abs(Math.cos(rad));
            const absSin = Math.abs(Math.sin(rad));
            const rotatedWidth = uploadedImage.width * absCos + uploadedImage.height * absSin;
            const rotatedHeight = uploadedImage.width * absSin + uploadedImage.height * absCos;

            let displayWidth = rotatedWidth;
            let displayHeight = rotatedHeight;

            // 移除自动 fit 逻辑
            // 图片尺寸完全由 currentZoom 控制
            // 初始状态下，currentZoom 已在 initCropArea 中被设为适合容器宽度的值(maxZoom)


            // Apply zoom
            displayWidth *= currentZoom;
            displayHeight *= currentZoom;

            const oldCanvasScale = canvasScale;
            canvasScale = displayWidth / rotatedWidth; // Scale of the image on the canvas relative to its rotated actual size

            // If scale changes, adjust crop box to maintain relative size and position
            if (oldCanvasScale && oldCanvasScale !== canvasScale && cropData.width) {
                const scaleRatio = canvasScale / oldCanvasScale;
                cropData.x *= scaleRatio;
                cropData.y *= scaleRatio;
                cropData.width *= scaleRatio;
                cropData.height *= scaleRatio;

                // 边界检查：防止放大且裁切框贴边时，因精度或偏移导致溢出
                // 始终将其限制在当前的显示范围内
                const maxW = displayWidth;
                const maxH = displayHeight;

                // 1. 尺寸不能超过画布
                if (cropData.width > maxW) cropData.width = maxW;
                if (cropData.height > maxH) cropData.height = maxH;

                // 2. 位置不能小于0
                if (cropData.x < 0) cropData.x = 0;
                if (cropData.y < 0) cropData.y = 0;

                // 3. 确保不溢出右下边界
                if (cropData.x + cropData.width > maxW) {
                    cropData.x = maxW - cropData.width;
                }
                if (cropData.y + cropData.height > maxH) {
                    cropData.y = maxH - cropData.height;
                }

                updateCropBox();
            }

            cropCanvas.width = displayWidth;
            cropCanvas.height = displayHeight;

            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.save();

            // Translate origin to center of canvas
            cropCtx.translate(cropCanvas.width / 2, cropCanvas.height / 2);
            cropCtx.scale(canvasScale, canvasScale);
            cropCtx.rotate(rad);

            // Draw image centered
            cropCtx.drawImage(uploadedImage, -uploadedImage.width / 2, -uploadedImage.height / 2);

            cropCtx.restore();
        }

        // 更新最大缩放限制
        function updateMaxZoom() {
            if (!uploadedImage) return;
            const wrapper = document.querySelector('.crop-canvas-wrapper');

            // 关键修正：直接使用 wrapper 自身的宽度作为最大限制
            // 因为我们在 CSS 中通过 negative margin 让 wrapper 比 parent 更宽（撑满了卡片）
            // 所以必须用 wrapper.clientWidth 才能获取到真正的“满宽”数值
            const currentWidth = wrapper.clientWidth;
            const maxWidth = currentWidth > 0 ? currentWidth : window.innerWidth;

            const rad = currentRotation * Math.PI / 180;
            const absCos = Math.abs(Math.cos(rad));
            const absSin = Math.abs(Math.sin(rad));
            const rotatedWidth = uploadedImage.width * absCos + uploadedImage.height * absSin;

            // 这里的缩放仅受容器当前宽度的物理限制，不再强制限制高度（由滚动或溢出处理）
            // 计算让图片填满容器所需的最大 Zoom 值
            // 限制 Zoom 上限，使得图片宽度永远不会超过容器宽度
            // 这样就防止了“数值增加单图片不变大”的问题
            maxZoom = maxWidth / rotatedWidth;

            // 更新输入框的最大值 (显示为百分比)
            // 允许一定的最小值以防计算异常
            if (maxZoom < 0.01) maxZoom = 0.01;

            if (zoomInput) {
                zoomInput.max = Math.floor(maxZoom * 100);
            }
        }

        // 重置裁切区域
        function resetCropArea() {
            const ratio = currentRatio.width / currentRatio.height;
            const canvasW = cropCanvas.width;
            const canvasH = cropCanvas.height;

            let width, height;
            if (canvasW / ratio <= canvasH) {
                width = canvasW;
                height = width / ratio; // Use width to calculate height based on ratio
            } else {
                height = canvasH;
                width = height * ratio; // Use height to calculate width based on ratio
            }

            cropData = {
                x: (canvasW - width) / 2,
                y: (canvasH - height) / 2,
                width: width,
                height: height
            };
            updateCropBox();
        }

        function updateZoomUI() {
            zoomInput.value = Math.round(currentZoom * 100);
            drawCanvas();
        }

        function getCanvasPoint(clientX, clientY) {
            const overlayRect = cropOverlay.getBoundingClientRect();
            const relX = clientX - overlayRect.left;
            const relY = clientY - overlayRect.top;
            return {
                x: (relX / overlayRect.width) * cropCanvas.width,
                y: (relY / overlayRect.height) * cropCanvas.height
            };
        }

        function updateCropBox() {
            // 计算 CSS 视觉尺寸与 Canvas 物理尺寸的比例
            // 当 CSS max-width 生效时，offsetWidth 会小于 width
            const visualScale = (cropCanvas.offsetWidth > 0 && cropCanvas.width > 0)
                ? cropCanvas.offsetWidth / cropCanvas.width
                : 1;

            cropBox.style.left = (cropData.x * visualScale) + 'px';
            cropBox.style.top = (cropData.y * visualScale) + 'px';
            cropBox.style.width = (cropData.width * visualScale) + 'px';
            cropBox.style.height = (cropData.height * visualScale) + 'px';
            updateCropInfo();
        }

        function updateCropInfo() {
            const actualWidth = Math.round(cropData.width / canvasScale);
            const actualHeight = Math.round(cropData.height / canvasScale);
            cropSizeElem.textContent = `${actualWidth} × ${actualHeight}`;
            const gcd = getGCD(actualWidth, actualHeight);
            const ratioW = actualWidth / gcd;
            const ratioH = actualHeight / gcd;
            cropRatioElem.textContent = `${ratioW}:${ratioH}`;
        }

        function getGCD(a, b) {
            return b === 0 ? a : getGCD(b, a % b);
        }

        // 事件监听器绑定
        const startDrag = (e) => {
            if (e.target.classList.contains('crop-handle') || e.target.classList.contains('corner-radius-handle')) return;
            isDragging = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const pt = getCanvasPoint(clientX, clientY);
            dragStart = { x: pt.x - cropData.x, y: pt.y - cropData.y };
            if (e.cancelable) e.preventDefault();
        };

        cropBox.addEventListener('mousedown', startDrag);
        cropBox.addEventListener('touchstart', startDrag, { passive: false });

        cropHandles.forEach(handle => {
            const startResize = (e) => {
                isResizing = true;
                currentHandle = handle.classList[1];
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const pt = getCanvasPoint(clientX, clientY);
                dragStart = {
                    x: pt.x, y: pt.y,
                    cropX: cropData.x, cropY: cropData.y,
                    cropW: cropData.width, cropH: cropData.height
                };
                if (e.cancelable) e.preventDefault();
                e.stopPropagation();
            };
            handle.addEventListener('mousedown', startResize);
            handle.addEventListener('touchstart', startResize, { passive: false });
        });

        document.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        document.addEventListener('touchmove', (e) => {
            if (isDragging || isResizing) {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
                if (e.cancelable) e.preventDefault();
            }
        }, { passive: false });

        function handleMove(clientX, clientY) {
            const pt = getCanvasPoint(clientX, clientY);
            if (isDragging) {
                cropData.x = Math.max(0, Math.min(pt.x - dragStart.x, cropCanvas.width - cropData.width));
                cropData.y = Math.max(0, Math.min(pt.y - dragStart.y, cropCanvas.height - cropData.height));
                updateCropBox();
            } else if (isResizing && currentHandle) {
                const dx = pt.x - dragStart.x;
                const dy = pt.y - dragStart.y;
                const ratio = currentRatio.width / currentRatio.height;

                let newX = dragStart.cropX;
                let newY = dragStart.cropY;
                let newW = dragStart.cropW;
                let newH = dragStart.cropH;

                if (currentHandle === 'crop-handle-se') {
                    newW = Math.max(50, dragStart.cropW + dx);
                    newH = newW / ratio;
                    if (newX + newW > cropCanvas.width) { newW = cropCanvas.width - newX; newH = newW / ratio; }
                    if (newY + newH > cropCanvas.height) { newH = cropCanvas.height - newY; newW = newH * ratio; }
                } else if (currentHandle === 'crop-handle-sw') {
                    newW = Math.max(50, dragStart.cropW - dx);
                    newH = newW / ratio;
                    if (newX + (dragStart.cropW - newW) < 0) { newW = newX + dragStart.cropW; newH = newW / ratio; }
                    if (newY + newH > cropCanvas.height) { newH = cropCanvas.height - newY; newW = newH * ratio; }
                    newX = dragStart.cropW + dragStart.cropX - newW;
                } else if (currentHandle === 'crop-handle-ne') {
                    newH = Math.max(50, dragStart.cropH - dy);
                    newW = newH * ratio;
                    if (newY + (dragStart.cropH - newH) < 0) { newH = newY + dragStart.cropH; newW = newH * ratio; }
                    if (newX + newW > cropCanvas.width) { newW = cropCanvas.width - newX; newH = newW / ratio; }
                    newY = dragStart.cropH + dragStart.cropY - newH;
                } else if (currentHandle === 'crop-handle-nw') {
                    newW = Math.max(50, dragStart.cropW - dx);
                    newH = newW / ratio;
                    if (newX + (dragStart.cropW - newW) < 0) { newW = newX + dragStart.cropW; newH = newW / ratio; }
                    if (newY + (dragStart.cropH - newH) < 0) { newH = newY + dragStart.cropH; newW = newH * ratio; }
                    newX = dragStart.cropW + dragStart.cropX - newW;
                    newY = dragStart.cropH + dragStart.cropY - newH;
                }

                cropData.x = newX;
                cropData.y = newY;
                cropData.width = newW;
                cropData.height = newH;
                updateCropBox();
            }
        }


        function clearAllStates() {
            isDragging = false;
            isResizing = false;
            isDraggingRadius = false;
            currentHandle = null;
            isGestureActive = false;
            activeRadiusHandle = null;
        }
        document.addEventListener('mouseup', clearAllStates);
        document.addEventListener('touchend', clearAllStates);

        resetCropBtn.addEventListener('click', () => {
            currentRotation = 0;
            currentZoom = 1;
            borderRadiusSlider.value = 0;
            borderRadiusInput.value = 0;
            rotationSlider.value = 0;
            rotationInput.value = 0;
            cropBox.style.borderRadius = '0px';
            updateMaxZoom();
            drawCanvas();
            resetCropArea();
            updateZoomUI();
        });

        cancelCropBtn.addEventListener('click', () => {
            preCropIndex = -1;
            uploadedImage = null;
            cropContainer.style.display = 'none';
            uploadPlaceholder.style.display = 'block';
            cropResult.style.display = 'none';
            window.isShowingCropResult = false;
            imageInput.value = '';
        });

        function showToast(message) {
            let toastEl = document.getElementById('toast');
            if (!toastEl) {
                toastEl = document.createElement('div');
                toastEl.id = 'toast';
                toastEl.className = 'toast-message';
                document.body.appendChild(toastEl);
            }
            toastEl.textContent = message;
            toastEl.classList.add('show');
            setTimeout(() => toastEl.classList.remove('show'), 2000);
        }

        cropBtn.addEventListener('click', performCrop);
        applyPreCropBtn.addEventListener('click', performCrop); // 裁切前的应用按钮，直接执行裁切


        savePreCropBtn.addEventListener('click', () => {
            const dataUrl = resultCanvas.toDataURL('image/png');
            const updateItem = (targetIndex) => {
                stitchImages[targetIndex].src = dataUrl;
                const img = new Image();
                img.onload = () => {
                    stitchImages[targetIndex].width = img.width;
                    stitchImages[targetIndex].height = img.height;
                    finishSaving();
                };
                img.src = dataUrl;
            };

            const finishSaving = () => {
                // 先重置选中状态，确保 updateStitchPreview 显示拼图而非单张
                preCropIndex = -1;
                isFromStitch = false;
                selectedImageIndex = -1;

                renderStitchImageList();
                updateStitchPreview();
                showStitchUI();
                showToast(currentLang === 'zh' ? '✅ 已更新到列表' : '✅ Updated to list');
                savePreCropBtn.style.display = 'none';
                setTimeout(() => {
                    const target = document.querySelector('.stitch-preview-container');
                    if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 300);
            };

            if (preCropIndex >= 0) {
                updateItem(preCropIndex);
            } else {
                // 普通裁切或拼接后裁切：作为新项追加到列表
                stitchImages.push({
                    src: dataUrl,
                    width: resultCanvas.width,
                    height: resultCanvas.height
                });
                finishSaving();
            }
        });

        function performCrop() {
            if (!uploadedImage) return;
            const actualW = Math.round(cropData.width / canvasScale);
            const actualH = Math.round(cropData.height / canvasScale);
            const actualX = Math.round(cropData.x / canvasScale);
            const actualY = Math.round(cropData.y / canvasScale);
            const borderRadius = parseInt(borderRadiusSlider.value);
            const actualRadius = borderRadius / canvasScale;

            resultCanvas.width = actualW;
            resultCanvas.height = actualH;
            const resCtx = resultCanvas.getContext('2d');
            resCtx.clearRect(0, 0, actualW, actualH);

            if (borderRadius > 0) {
                resCtx.beginPath();
                resCtx.moveTo(actualRadius, 0);
                resCtx.arcTo(actualW, 0, actualW, actualH, actualRadius);
                resCtx.arcTo(actualW, actualH, 0, actualH, actualRadius);
                resCtx.arcTo(0, actualH, 0, 0, actualRadius);
                resCtx.arcTo(0, 0, actualW, 0, actualRadius);
                resCtx.closePath();
                resCtx.clip();
            }

            resCtx.save();
            resCtx.translate(-actualX, -actualY);
            const rotatedCanvas = document.createElement('canvas');
            const rad = currentRotation * Math.PI / 180;
            const absCos = Math.abs(Math.cos(rad));
            const absSin = Math.abs(Math.sin(rad));
            const bw = uploadedImage.width * absCos + uploadedImage.height * absSin;
            const bh = uploadedImage.width * absSin + uploadedImage.height * absCos;
            rotatedCanvas.width = bw;
            rotatedCanvas.height = bh;
            const bctx = rotatedCanvas.getContext('2d');
            bctx.translate(bw / 2, bh / 2);
            bctx.rotate(rad);
            bctx.drawImage(uploadedImage, -uploadedImage.width / 2, -uploadedImage.height / 2);
            resCtx.drawImage(rotatedCanvas, 0, 0);
            resCtx.restore();

            cropContainer.style.display = 'none';
            cropResult.style.display = 'block';
            window.isShowingCropResult = true; // Added
            updateLanguage(currentLang); // Added as per instruction snippet
            stitchContainer.style.display = 'none';

            // 永远显示“应用到列表”，方便用户将裁切结果反哺给拼接列表
            savePreCropBtn.style.display = 'flex';
            downloadBtn.style.display = 'flex';
            copyBtn.style.display = 'flex';
            newCropBtn.style.display = 'flex';

            if (preCropIndex >= 0 || isFromStitch) {
                savePreCropBtn.className = 'crop-action-btn crop-btn-success';
                downloadBtn.className = 'crop-action-btn crop-btn-primary';
            } else {
                // 普通裁切模式下，应用到列表也是一个很棒的选项
                savePreCropBtn.className = 'crop-action-btn crop-btn-primary';
                downloadBtn.className = 'crop-action-btn crop-btn-success';
            }
            setTimeout(() => cropResult.scrollIntoView({ behavior: 'smooth', block: 'nearest' }), 100);
        }

        downloadBtn.addEventListener('click', () => {
            resultCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `cropped_${Date.now()}.png`;
                link.href = url;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(url), 100);
            }, 'image/png');
        });

        copyBtn.addEventListener('click', async () => {
            if (!resultCanvas) {
                showToast(currentLang === 'zh' ? '❌ 没有可复制的图片' : '❌ No image to copy');
                return;
            }

            const btnSpan = copyBtn.querySelector('span');
            const originalText = btnSpan.textContent;

            await copyImageToClipboard(
                resultCanvas,
                () => {
                    // 成功反馈
                    btnSpan.textContent = translations[currentLang].imageCrop.copiedBtn;
                    copyBtn.classList.remove('crop-btn-primary');
                    copyBtn.classList.add('crop-btn-success');
                    showToast(currentLang === 'zh' ? '✅ 已复制到剪贴板' : '✅ Copied to clipboard');

                    setTimeout(() => {
                        btnSpan.textContent = originalText;
                        copyBtn.classList.remove('crop-btn-success');
                        copyBtn.classList.add('crop-btn-primary');
                    }, 2000);
                },
                () => {
                    // 复制失败处理逻辑
                    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

                    // 如果是 Safari 或移动端，尝试自动下载作为 Fallback
                    if (isMobile || isSafari) {
                        try {
                            const link = document.createElement('a');
                            link.download = `ratio-crop-${new Date().getTime()}.png`;
                            link.href = resultCanvas.toDataURL('image/png');
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            showToast(currentLang === 'zh' ? '⚠️ 浏览器限制无法直接复制，已自动为您下载' : '⚠️ Copied failed, downloading instead');
                        } catch (e) {
                            showToast(currentLang === 'zh' ? '❌ 复制失败，请尝试手动下载' : '❌ Copy failed, please download manually');
                        }
                    } else {
                        showToast(currentLang === 'zh' ? '❌ 复制失败，请尝试下载' : '❌ Copy failed, try download');
                    }
                }
            );
        });


        newCropBtn.addEventListener('click', () => cancelCropBtn.click());

        const originalUpdateRatio = updateRatio;
        updateRatio = function (width, height) {
            originalUpdateRatio(width, height);
            if (uploadedImage && cropContainer.style.display !== 'none') resetCropArea();
            const opContainer = document.getElementById('outpaintingContainer');
            if (opContainer && opContainer.style.display !== 'none') initOutpaintingBase();
        };

        const devCard = document.getElementById('devCard');
        const toggleDevCardBtn = document.getElementById('toggleDevCard');
        const devAvatar = document.getElementById('devAvatar');
        const devAvatarLink = document.getElementById('devAvatarLink');
        let isCollapsed = false;
        toggleDevCardBtn.addEventListener('click', () => {
            isCollapsed = !isCollapsed;
            devCard.classList.toggle('collapsed', isCollapsed);
            toggleDevCardBtn.textContent = isCollapsed ? translations[currentLang].developer.expand : translations[currentLang].developer.collapse;
        });
        devAvatarLink.addEventListener('click', (e) => {
            if (isCollapsed) {
                e.preventDefault();
                isCollapsed = false;
                devCard.classList.remove('collapsed');
                toggleDevCardBtn.textContent = translations[currentLang].developer.collapse;
            }
        });

        // ========== 扩图底板与 Tab 切换逻辑 (新增) ==========
        const toolTabs = document.querySelectorAll('.tool-icon-btn');

        const outpaintingContainer = document.getElementById('outpaintingContainer');
        const outpaintingCanvas = document.getElementById('outpaintingCanvas');
        const outpaintingCtx = outpaintingCanvas.getContext('2d');
        const outpaintingOverlay = document.getElementById('outpaintingOverlay');
        const outpaintingPlaceholder = document.getElementById('outpaintingPlaceholder');
        const outpaintingInput = document.getElementById('outpaintingInput');
        const outpaintingSizeDisplay = document.getElementById('outpaintingSizeDisplay');
        const confirmOutpaintingBtn = document.getElementById('confirmOutpaintingBtn');
        const downloadOutpaintingBtn = document.getElementById('downloadOutpaintingBtn');
        const copyOutpaintingBtn = document.getElementById('copyOutpaintingBtn');
        const resetOutpaintingBtn = document.getElementById('resetOutpaintingBtn');
        const cancelOutpaintingBtn = document.getElementById('cancelOutpaintingBtn');

        // 当前激活的扩图图片元素
        let activeOutpaintingImg = null;
        let isDraggingOutpainting = false;
        let isResizingOutpainting = false;
        let isRotatingOutpainting = false;
        let dragOutpaintingStartX, dragOutpaintingStartY;
        let imgOutpaintingStartX, imgOutpaintingStartY;
        let outpaintingInitialRect = null;
        let outpaintingResizeHandle = null;
        let outpaintingStartAngle = 0;
        let outpaintingInitialRotation = 0;
        let outpaintingCenterX = 0;
        let outpaintingCenterY = 0;

        // 初始化 Tab 切换
        toolTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tool = tab.dataset.tool;

                // 1. 更新卡片标题
                const titleKey = currentLang === 'zh' ? 'zh' : 'en';
                const titleElem = document.querySelector('.image-crop-section .card-title');
                if (titleElem) titleElem.textContent = toolLabels[tool][titleKey];

                // 2. 更新 Tab 激活状态
                toolTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // 3. 切换视图
                // 先隐藏所有
                if (uploadArea) uploadArea.style.display = 'none';
                if (cropContainer) cropContainer.style.display = 'none';
                if (stitchContainer) stitchContainer.style.display = 'none';
                if (outpaintingContainer) outpaintingContainer.style.display = 'none';
                if (cropResult) cropResult.style.display = 'none';

                // 4. 彻底物理隔离：显示/隐藏各自的比例配置组
                const cropRatioGroup = document.getElementById('cropRatioGroup');
                const opRatioGroup = document.getElementById('opRatioGroup');

                if (tool === 'image-tool') {
                    if (cropRatioGroup) cropRatioGroup.style.display = 'contents';
                    if (opRatioGroup) opRatioGroup.style.display = 'none';

                    // 核心状态标志位
                    const hasStitchImages = stitchImages.length > 0;
                    const isPreCropping = preCropIndex !== -1;
                    const isStitchCropping = isFromStitch;
                    const isSingleCropping = (uploadedImage && !hasStitchImages);
                    const isCurrentlyCropping = (isPreCropping || isStitchCropping || isSingleCropping);
                    const isShowingResult = window.isShowingCropResult && resultCanvas;

                    // 视觉预重置
                    if (uploadArea) uploadArea.style.display = 'none';
                    if (stitchContainer) stitchContainer.style.display = 'none';
                    if (cropContainer) cropContainer.style.display = 'none';
                    if (cropResult) cropResult.style.display = 'none';

                    if (isShowingResult) {
                        // 场景 1: 展示裁切结果页
                        cropResult.style.display = 'block';
                    } else if (isCurrentlyCropping) {
                        // 场景 2: 正在裁切工作中
                        cropContainer.style.display = 'block';
                    } else if (hasStitchImages) {
                        // 场景 3: 拼接管理阶段
                        if (uploadArea) {
                            uploadArea.style.display = 'block';
                            if (uploadPlaceholder) uploadPlaceholder.style.display = 'none';
                            if (stitchContainer) {
                                stitchContainer.style.display = 'block';
                                renderStitchImageList();
                                updateStitchPreview();
                            }
                        }
                    } else {
                        // 场景 4: 初始上传态
                        if (uploadArea) {
                            uploadArea.style.display = 'block';
                            if (uploadPlaceholder) uploadPlaceholder.style.display = 'flex';
                        }
                    }
                } else if (tool === 'outpainting') {
                    if (cropRatioGroup) cropRatioGroup.style.display = 'none';
                    if (opRatioGroup) opRatioGroup.style.display = 'contents';

                    // 同步比例：共用比例裁剪器的比例
                    if (typeof currentRatio !== 'undefined' && typeof opCurrentRatio !== 'undefined') {
                        opCurrentRatio = { ...currentRatio };
                        if (typeof opCurrentRatioText !== 'undefined') {
                            opCurrentRatioText.textContent = `${opCurrentRatio.width}:${opCurrentRatio.height}`;
                        }
                        // 同步按钮激活状态
                        if (typeof opRatioButtons !== 'undefined') {
                            opRatioButtons.forEach(btn => {
                                const [w, h] = btn.dataset.ratio.split(':').map(Number);
                                if (w === opCurrentRatio.width && h === opCurrentRatio.height) {
                                    btn.classList.add('active');
                                } else {
                                    btn.classList.remove('active');
                                }
                            });
                        }
                    }

                    outpaintingContainer.style.display = 'block';
                    initOutpaintingBase();
                    // 确保重置所有状态
                    isDraggingOutpainting = false;
                    isResizingOutpainting = false;
                    isRotatingOutpainting = false;

                    // 关键修复：如果当前处于“已合成”状态（取消按钮显示中），则切换回来时需要重新渲染画面
                    if (cancelOutpaintingBtn && cancelOutpaintingBtn.style.display !== 'none') {
                        renderMergedOutpainting();
                    }
                }
            });
        });

        // 提取渲染合成图像的逻辑，以便在切换标签时复用
        function renderMergedOutpainting() {
            if (!outpaintingCanvas || !outpaintingCtx) return;

            // 1. 重新绘制纯绿色背景 (确保底色干净)
            const w = outpaintingCanvas.width;
            const h = outpaintingCanvas.height;
            outpaintingCtx.fillStyle = '#00FF00';
            outpaintingCtx.fillRect(0, 0, w, h);

            // 2. 绘制所有悬浮层中的图片到画布
            const wrapper = document.getElementById('outpaintingWrapper');
            if (!wrapper) return;

            const canvasW = outpaintingCanvas.width;
            const visualW = parseFloat(wrapper.style.width);
            const scaleRatio = canvasW / visualW;

            const items = outpaintingOverlay.querySelectorAll('.outpainting-item');
            items.forEach(item => {
                const img = item.querySelector('img');
                if (!img) return;

                const rotation = parseFloat(item.dataset.rotation || 0) * Math.PI / 180;
                const rect = {
                    left: parseFloat(item.style.left),
                    top: parseFloat(item.style.top),
                    width: parseFloat(item.style.width),
                    height: parseFloat(item.style.height)
                };

                outpaintingCtx.save();
                // 移动到图片中心
                const centerX = (rect.left + rect.width / 2) * scaleRatio;
                const centerY = (rect.top + rect.height / 2) * scaleRatio;
                outpaintingCtx.translate(centerX, centerY);
                // 旋转
                outpaintingCtx.rotate(rotation);
                // 绘制 (注意这里要把坐标移回左上角)
                outpaintingCtx.drawImage(
                    img,
                    -rect.width / 2 * scaleRatio,
                    -rect.height / 2 * scaleRatio,
                    rect.width * scaleRatio,
                    rect.height * scaleRatio
                );
                outpaintingCtx.restore();
            });
        }

        // 初始化扩图底板
        function initOutpaintingBase() {
            // 获取尺寸：优先使用用户输入的宽/高，或者计算出的宽/高
            // 注意：需要确保元素存在
            // 获取尺寸：优先使用扩图面板下的独立输入
            const iw = document.getElementById('opInputWidth');
            const ih = document.getElementById('opInputHeight');
            const cw = document.getElementById('opCalcWidth');
            const ch = document.getElementById('opCalcHeight');
            const custW = document.getElementById('opCustomWidth');
            const custH = document.getElementById('opCustomHeight');

            // 使用 opCurrentRatio 代替全局 currentRatio
            let w = Math.min(5000, parseFloat(iw?.value) || parseFloat(cw?.value) || parseFloat(custW?.value) || 1280);
            let h = Math.min(5000, parseFloat(ih?.value) || parseFloat(ch?.value) || parseFloat(custH?.value) || 720);

            // 如果没有任何输入，尝试基于该模块当前选中的比例按钮计算
            if (w === 1280 && h === 720 && typeof opCurrentRatio !== 'undefined') {
                w = 1200;
                h = (w / opCurrentRatio.width) * opCurrentRatio.height;
            }

            // 强制同步计算器的最新值 (如果计算器有值)
            if (cw?.value && ch?.value) {
                w = parseFloat(iw?.value || cw?.value);
                h = parseFloat(ih?.value || ch?.value);
            }

            // 更新显示
            if (outpaintingSizeDisplay) outpaintingSizeDisplay.textContent = `${Math.round(w)} x ${Math.round(h)}`;

            // 设置 Canvas 尺寸 (实际像素)
            outpaintingCanvas.width = w;
            outpaintingCanvas.height = h;

            // 填充纯绿色背景 (必须是绝对纯绿 #00FF00，严禁色差，以便后期色键抠图)
            outpaintingCtx.fillStyle = '#00FF00';
            outpaintingCtx.fillRect(0, 0, w, h);

            // 调整 Wrapper 尺寸以适应屏幕，保持比例
            const wrapper = document.getElementById('outpaintingWrapper');
            if (!wrapper) return;

            const maxWidth = wrapper.parentElement.clientWidth - 40; // 减去 padding
            const maxHeight = 600; // 最大高度限制

            // 计算缩放比例以适应容器
            const scaleW = maxWidth / w;
            const scaleH = maxHeight / h;
            const scale = Math.min(scaleW, scaleH, 1); // 不放大，只通过CSS缩放来适应屏幕

            wrapper.style.width = `${w * scale}px`;
            wrapper.style.height = `${h * scale}px`;

            // 重新绘制背景以便它是干净的 (CSS缩放不会模糊Canvas内容，但会影响点击坐标)
        }

        // 监听尺寸输入变化，实时更新底板 (增加防抖处理，防止频繁触发导致性能问题或冻结)
        let opResizeTimeout;
        const watchOpInputs = ['opInputWidth', 'opInputHeight', 'opCalcWidth', 'opCalcHeight'];
        watchOpInputs.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', () => {
                    const opBtn = document.querySelector('[data-tool="outpainting"]');
                    if (opBtn && opBtn.classList.contains('active')) {
                        clearTimeout(opResizeTimeout);
                        opResizeTimeout = setTimeout(() => {
                            initOutpaintingBase();
                            // 如果合成过，重置也是为了性能和逻辑正确
                            if (cancelOutpaintingBtn && cancelOutpaintingBtn.style.display !== 'none') {
                                cancelOutpaintingBtn.click();
                            }
                        }, 300);
                    }
                });
            }
        });

        // 点击上传
        if (outpaintingPlaceholder) {
            outpaintingPlaceholder.addEventListener('click', () => {
                outpaintingInput.click();
            });
        }

        if (outpaintingInput) {
            outpaintingInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    addOutpaintingImage(e.target.files[0]);
                    e.target.value = ''; // 重置
                }
            });
        }

        // 扩图底板拖拽支持
        if (outpaintingOverlay) {
            outpaintingOverlay.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const wrapper = document.getElementById('outpaintingWrapper');
                if (wrapper) wrapper.style.boxShadow = '0 0 20px var(--border-glow)';
            });

            outpaintingOverlay.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const wrapper = document.getElementById('outpaintingWrapper');
                if (wrapper) wrapper.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
            });

            outpaintingOverlay.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const wrapper = document.getElementById('outpaintingWrapper');
                if (wrapper) wrapper.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';

                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                if (files.length > 0) {
                    addOutpaintingImage(files[0]);
                }
            });
        }

        // 粘贴上传 (修复语法错误)
        document.addEventListener('paste', (e) => {
            const isOutpaintingActive = document.querySelector('[data-tool="outpainting"]').classList.contains('active');
            if (!isOutpaintingActive) return;

            const items = e.clipboardData.items;
            const imageFiles = Array.from(items).filter(item => item.type.startsWith('image/'));
            if (imageFiles.length > 0) {
                const files = imageFiles.map(item => item.getAsFile()).filter(f => f);
                // Assuming handleMultipleFiles is a function that can process an array of files
                // For outpainting, we typically only add one image at a time, so we'll take the first one.
                if (files.length > 0) {
                    addOutpaintingImage(files[0]);
                    e.preventDefault();
                }
            }
        });

        // 移除重复声明部分

        function addOutpaintingImage(file) {
            const img = new Image();
            img.src = URL.createObjectURL(file);
            img.onload = () => {
                const wrapper = document.getElementById('outpaintingWrapper');
                // 初始大小：如果图片太大，缩放到 wrapper 的 80%
                let displayW = img.width;
                let displayH = img.height;

                const wrapperW = parseFloat(wrapper.style.width);
                const wrapperH = parseFloat(wrapper.style.height);

                // 简单的自适应初始大小
                if (displayW > wrapperW * 0.8) {
                    const ratio = (wrapperW * 0.8) / displayW;
                    displayW *= ratio;
                    displayH *= ratio;
                }

                // 创建包装容器
                const itemWrapper = document.createElement('div');
                itemWrapper.className = 'outpainting-item-wrapper outpainting-item';
                itemWrapper.style.width = `${displayW}px`;
                itemWrapper.style.height = `${displayH}px`;
                itemWrapper.style.left = `${(wrapperW - displayW) / 2}px`;
                itemWrapper.style.top = `${(wrapperH - displayH) / 2}px`;

                const imgEl = document.createElement('img');
                imgEl.src = img.src;
                itemWrapper.appendChild(imgEl);

                // 添加控制手柄
                const handles = ['nw', 'ne', 'sw', 'se', 'rot'];
                handles.forEach(h => {
                    const handle = document.createElement('div');
                    handle.className = `op-handle op-handle-${h}`;
                    handle.dataset.handle = h;
                    itemWrapper.appendChild(handle);
                });

                // 初始化旋转信息
                itemWrapper.dataset.rotation = 0;
                itemWrapper.style.transform = 'rotate(0deg)';
                updateOutpaintingCursors(itemWrapper); // 初始化光标

                // 绑定交互事件
                bindOutpaintingInteraction(itemWrapper);

                const outpaintingOverlay = document.getElementById('outpaintingOverlay');
                outpaintingOverlay.appendChild(itemWrapper);
                const outpaintingPlaceholder = document.getElementById('outpaintingPlaceholder');
                outpaintingPlaceholder.style.display = 'none'; // 隐藏占位符
                activeOutpaintingImg = itemWrapper;

                // 设为激活
                document.querySelectorAll('.outpainting-item').forEach(i => i.classList.remove('active'));
                itemWrapper.classList.add('active');
            };
        }

        function bindOutpaintingInteraction(el) {
            // 鼠标按下：区分移动还是缩放
            el.addEventListener('mousedown', (e) => {
                e.preventDefault();
                activeOutpaintingImg = el;

                // 选中逻辑
                document.querySelectorAll('.outpainting-item').forEach(item => item.classList.remove('active'));
                el.classList.add('active');

                if (e.target.classList.contains('op-handle')) {
                    const hType = e.target.dataset.handle;
                    if (hType === 'rot') {
                        // 开始旋转
                        isRotatingOutpainting = true;
                        const rect = el.getBoundingClientRect();
                        // 锁定中心点坐标，避免旋转引起的 rect 变化导致计算漂移
                        outpaintingCenterX = rect.left + rect.width / 2;
                        outpaintingCenterY = rect.top + rect.height / 2;
                        outpaintingStartAngle = Math.atan2(e.clientY - outpaintingCenterY, e.clientX - outpaintingCenterX);
                        outpaintingInitialRotation = parseFloat(el.dataset.rotation || 0);
                    } else {
                        // 开始缩放
                        isResizingOutpainting = true;
                        outpaintingResizeHandle = hType;
                        outpaintingInitialRect = {
                            left: parseFloat(el.style.left),
                            top: parseFloat(el.style.top),
                            width: parseFloat(el.style.width),
                            height: parseFloat(el.style.height),
                            startX: e.clientX,
                            startY: e.clientY,
                            ratio: parseFloat(el.style.width) / parseFloat(el.style.height),
                            rotation: (parseFloat(el.dataset.rotation || 0) * Math.PI) / 180
                        };
                    }
                } else {
                    // 开始移动
                    isDraggingOutpainting = true;
                    dragOutpaintingStartX = e.clientX;
                    dragOutpaintingStartY = e.clientY;
                    imgOutpaintingStartX = parseFloat(el.style.left);
                    imgOutpaintingStartY = parseFloat(el.style.top);
                }
                e.stopPropagation();
            });

            // 滚轮缩放同步适配 Wrapper 尺寸
            el.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scaleFactor = e.deltaY > 0 ? 0.95 : 1.05;
                const currentW = parseFloat(el.style.width);
                const currentH = parseFloat(el.style.height);

                const newW = currentW * scaleFactor;
                const newH = currentH * scaleFactor;

                // 中心点缩放
                const cx = parseFloat(el.style.left) + currentW / 2;
                const cy = parseFloat(el.style.top) + currentH / 2;

                el.style.width = `${newW}px`;
                el.style.height = `${newH}px`;
                el.style.left = `${cx - newW / 2}px`;
                el.style.top = `${cy - newH / 2}px`;
            });

            // 处理触控开始
            el.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) return; // 忽略多指
                const touch = e.touches[0];
                activeOutpaintingImg = el;

                // 选中逻辑
                document.querySelectorAll('.outpainting-item').forEach(item => item.classList.remove('active'));
                el.classList.add('active');

                if (e.target.classList.contains('op-handle')) {
                    isResizingOutpainting = true;
                    resizeHandle = e.target.dataset.handle;
                    initialRect = {
                        left: parseFloat(el.style.left),
                        top: parseFloat(el.style.top),
                        width: parseFloat(el.style.width),
                        height: parseFloat(el.style.height),
                        startX: touch.clientX,
                        startY: touch.clientY,
                        ratio: parseFloat(el.style.width) / parseFloat(el.style.height)
                    };
                } else {
                    isDraggingOutpainting = true;
                    dragStartX = touch.clientX;
                    dragStartY = touch.clientY;
                    imgStartX = parseFloat(el.style.left);
                    imgStartY = parseFloat(el.style.top);
                }
                if (e.cancelable) e.preventDefault();
                e.stopPropagation();
            }, { passive: false });
        }

        // 动态更新缩放手柄的光标，使其始终指向中心/外侧
        function updateOutpaintingCursors(el) {
            const rotation = parseFloat(el.dataset.rotation || 0);
            const cursors = ['n-resize', 'ne-resize', 'e-resize', 'se-resize', 's-resize', 'sw-resize', 'w-resize', 'nw-resize'];
            // 定义四个角的初始方位角
            const baseAngles = { 'nw': 315, 'ne': 45, 'se': 135, 'sw': 225 };

            Object.keys(baseAngles).forEach(handle => {
                const handleEl = el.querySelector(`.op-handle-${handle}`);
                if (handleEl) {
                    // 计算旋转后的总角度
                    const currentAngle = (baseAngles[handle] + rotation) % 360;
                    // 映射到 8 个方向索引 (每个方向 45度)
                    // (angle + 22.5) / 45 确保四舍五入到最近的 45度
                    const index = Math.floor(((currentAngle + 360) % 360 + 22.5) / 45) % 8;
                    handleEl.style.cursor = cursors[index];
                }
            });
        }

        function handleOutpaintingMove(clientX, clientY) {
            if (isDraggingOutpainting && activeOutpaintingImg) {
                const dx = clientX - dragOutpaintingStartX;
                const dy = clientY - dragOutpaintingStartY;
                activeOutpaintingImg.style.left = `${imgOutpaintingStartX + dx}px`;
                activeOutpaintingImg.style.top = `${imgOutpaintingStartY + dy}px`;
            } else if (isRotatingOutpainting && activeOutpaintingImg) {
                // 使用之前锁定的中心点进行计算
                const currentAngle = Math.atan2(clientY - outpaintingCenterY, clientX - outpaintingCenterX);
                let rotation = outpaintingInitialRotation + (currentAngle - outpaintingStartAngle) * (180 / Math.PI);
                activeOutpaintingImg.dataset.rotation = rotation;
                activeOutpaintingImg.style.transform = `rotate(${rotation}deg)`;
                // 实时更新光标方向
                updateOutpaintingCursors(activeOutpaintingImg);
            } else if (isResizingOutpainting && activeOutpaintingImg) {
                const dx = clientX - outpaintingInitialRect.startX;
                const dy = clientY - outpaintingInitialRect.startY;
                const theta = outpaintingInitialRect.rotation;

                // 将屏幕空间的位移转换到图片坐标系中 (局部 $dx'$, $dy'$)
                const localDx = dx * Math.cos(theta) + dy * Math.sin(theta);
                const localDy = -dx * Math.sin(theta) + dy * Math.cos(theta);

                let factorX = 0, factorY = 0;
                if (outpaintingResizeHandle === 'se') { factorX = 1; factorY = 1; }
                else if (outpaintingResizeHandle === 'sw') { factorX = -1; factorY = 1; }
                else if (outpaintingResizeHandle === 'ne') { factorX = 1; factorY = -1; }
                else if (outpaintingResizeHandle === 'nw') { factorX = -1; factorY = -1; }

                // 计算新尺寸
                let changeW = localDx * factorX;
                let newW = Math.max(20, outpaintingInitialRect.width + changeW);
                let actualChangeW = newW - outpaintingInitialRect.width;
                let actualChangeH = actualChangeW / outpaintingInitialRect.ratio;
                let newH = outpaintingInitialRect.height + actualChangeH;

                // 更新宽高
                activeOutpaintingImg.style.width = `${newW}px`;
                activeOutpaintingImg.style.height = `${newH}px`;

                // 核心控制：由于 transform-origin 在中心，改变宽高会导致四角同时移动
                // 我们需要移动中心点 (left, top) 来抵消缩放带来的位移，从而固定住对角点
                // 局部空间中心位移
                const localOffsetX = (actualChangeW * factorX) / 2;
                const localOffsetY = (actualChangeH * factorY) / 2;

                // 将局部偏移转回到屏幕/父容器坐标系
                const globalOffsetX = localOffsetX * Math.cos(theta) - localOffsetY * Math.sin(theta);
                const globalOffsetY = localOffsetX * Math.sin(theta) + localOffsetY * Math.cos(theta);

                activeOutpaintingImg.style.left = `${outpaintingInitialRect.left + globalOffsetX}px`;
                activeOutpaintingImg.style.top = `${outpaintingInitialRect.top + globalOffsetY}px`;
            }
        }

        document.addEventListener('mousemove', (e) => {
            handleOutpaintingMove(e.clientX, e.clientY);
        });

        document.addEventListener('touchmove', (e) => {
            if (isDraggingOutpainting || isResizingOutpainting) {
                const touch = e.touches[0];
                handleOutpaintingMove(touch.clientX, touch.clientY);
                if (e.cancelable) e.preventDefault();
            }
        }, { passive: false });

        const clearOutpaintingStates = () => {
            isDraggingOutpainting = false;
            isResizingOutpainting = false;
            isRotatingOutpainting = false;
        };
        document.addEventListener('mouseup', clearOutpaintingStates);
        document.addEventListener('touchend', clearOutpaintingStates);

        // 点击空白处取消选中
        if (outpaintingOverlay) {
            outpaintingOverlay.addEventListener('mousedown', (e) => {
                if (e.target === outpaintingOverlay) {
                    document.querySelectorAll('.outpainting-item').forEach(img => img.classList.remove('active'));
                }
            });
        }

        // 确认合成
        if (confirmOutpaintingBtn) {
            confirmOutpaintingBtn.addEventListener('click', () => {
                // 调用统一渲染函数
                renderMergedOutpainting();

                // 3. 状态切换：隐藏交互层（禁用拖拽），切换按钮
                outpaintingOverlay.style.display = 'none';
                confirmOutpaintingBtn.style.display = 'none';
                cancelOutpaintingBtn.style.display = 'inline-flex';
                downloadOutpaintingBtn.style.display = 'inline-flex';
                copyOutpaintingBtn.style.display = 'inline-flex';

                if (toast) showToast(currentLang === 'zh' ? '✅ 合成成功！' : '✅ Merged successfully!');
            });
        }

        // 取消合成（悔棋项）
        if (cancelOutpaintingBtn) {
            cancelOutpaintingBtn.addEventListener('click', () => {
                // 1. 重新初始化背景（清除合成结果）
                initOutpaintingBase();

                // 2. 恢复交互层和原始按钮
                outpaintingOverlay.style.display = 'block';
                confirmOutpaintingBtn.style.display = 'inline-flex';
                cancelOutpaintingBtn.style.display = 'none';
                downloadOutpaintingBtn.style.display = 'none';
                copyOutpaintingBtn.style.display = 'none';
            });
        }

        // 复制结果
        if (copyOutpaintingBtn) {
            copyOutpaintingBtn.addEventListener('click', async () => {
                const btnSpan = copyOutpaintingBtn.querySelector('span:last-child');
                const originalText = btnSpan.textContent;

                await copyImageToClipboard(
                    outpaintingCanvas,
                    () => {
                        btnSpan.textContent = translations[currentLang].outpainting.copied;
                        copyOutpaintingBtn.classList.remove('crop-btn-primary');
                        copyOutpaintingBtn.classList.add('crop-btn-success');
                        showToast(translations[currentLang].outpainting.copied);

                        setTimeout(() => {
                            btnSpan.textContent = originalText;
                            copyOutpaintingBtn.classList.remove('crop-btn-success');
                            copyOutpaintingBtn.classList.add('crop-btn-primary');
                        }, 2000);
                    },
                    () => {
                        showToast(currentLang === 'zh' ? '❌ 复制失败' : '❌ Copy failed');
                    }
                );
            });
        }

        // 下载结果
        if (downloadOutpaintingBtn) {
            downloadOutpaintingBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `outpainting_${Date.now()}.png`;
                link.href = outpaintingCanvas.toDataURL('image/png');
                link.click();
            });
        }

        // 重置
        if (resetOutpaintingBtn) {
            resetOutpaintingBtn.addEventListener('click', () => {
                // 1. 清除所有上传的图片，但保留 placeholder
                const items = outpaintingOverlay.querySelectorAll('.outpainting-item');
                items.forEach(item => item.remove());

                // 2. 恢复初始状态
                outpaintingOverlay.style.display = 'block';
                outpaintingPlaceholder.style.display = 'flex';
                confirmOutpaintingBtn.style.display = 'inline-flex';
                cancelOutpaintingBtn.style.display = 'none';
                downloadOutpaintingBtn.style.display = 'none';
                copyOutpaintingBtn.style.display = 'none';

                // 3. 重新绘制空背景
                initOutpaintingBase();
            });
        }
    </script>

    <script defer src="https://cloud.umami.is/script.js"
        data-website-id="4085ec3a-d6fc-4172-a6c7-fcae06d448f2"></script>
</body>

</html>